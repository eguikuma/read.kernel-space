<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# なぜメモリは4KB単位なのか

## はじめに

[03-virtual-memory](../03-virtual-memory.md) の「ページングの仕組み」で、メモリは<strong>ページ</strong>という単位で管理されると学びました

```bash
getconf PAGESIZE
```

このコマンドを実行すると、多くの環境で `4096`（4KB）と表示されます

でも、なぜ 4KB なのでしょうか？

`malloc(1)` で 1 バイトだけ欲しいのに、内部では 4KB 単位で管理されているのは無駄ではないでしょうか？

このドキュメントでは、ページサイズが 4KB になった歴史的な経緯と、その設計上のトレードオフを説明します

---

## 目次

- [ページとは何か](#ページとは何か)
- [なぜ4KBなのか](#なぜ4kbなのか)
- [ページテーブルの仕組み](#ページテーブルの仕組み)
- [TLBとは](#tlbとは)
- [Huge Pages](#huge-pages)
- [ページサイズの確認方法](#ページサイズの確認方法)
- [まとめ](#まとめ)
- [参考資料](#参考資料)

---

## ページとは何か

### メモリ管理の最小単位

<strong>ページ</strong>は、カーネルがメモリを管理する最小単位です

Linux カーネルのドキュメントでは、以下のように説明されています

> Memory is managed in fixed-size blocks called pages.

> メモリはページと呼ばれる固定サイズのブロックで管理されます

カーネルは、メモリを 1 バイト単位ではなく、ページ単位で扱います

- 物理メモリの割り当て → ページ単位
- 仮想アドレスから物理アドレスへの変換 → ページ単位
- スワップへの退避 → ページ単位

### 日常の例え

ページを「本棚の仕切り」に例えてみましょう

本棚に本を並べるとき、1 冊ごとに仕切りを調整するのは大変です

代わりに、一定間隔で仕切りを固定しておき、その区画単位で管理します

- 薄い本でも 1 区画を使う（少し無駄になる）
- 厚い本は 2 区画以上使う

「1 冊ごとにぴったりのスペース」より、「固定サイズの区画」で管理する方が、本の出し入れや整理が簡単になります

メモリのページも同様に、固定サイズの「区画」として管理することで、割り当てや解放を効率的に行えます

---

## なぜ4KBなのか

### 歴史的な経緯

4KB というページサイズは、1980 年代の VAX-11 というコンピュータに由来します

当時のコンピュータは、今よりもはるかにメモリが少なく（数 MB 程度）、CPU も遅い時代でした

その中で、以下のバランスを取る必要がありました

<strong>業界標準としての確立</strong>

VAX-11 で 4KB が採用された後、この値は業界標準として広がりました

| 年代      | 出来事                                                    |
| --------- | --------------------------------------------------------- |
| 1970 年代 | VAX-11 が 4KB ページを採用                                |
| 1985 年   | Intel 80386 が 4KB ページを採用（PC 市場への普及）        |
| 1990 年代 | Linux が 80386 をターゲットに開発、4KB を継承             |
| 現在      | x86_64、ARM64 など主要アーキテクチャが 4KB を基本サイズに |

一度標準化されると、変更は困難です

ファイルシステム、ネットワークプロトコル、アプリケーションなど、多くのソフトウェアが 4KB を前提に設計されているためです

### トレードオフ

<strong>ページサイズが小さすぎる場合</strong>

- ページテーブルが巨大になる（管理コストが増大）
- ディスク I/O が非効率（細切れの読み書きが多発）

<strong>ページサイズが大きすぎる場合</strong>

- 内部断片化が増える（使わない領域が無駄になる）
- 小さなプログラムがメモリを大量消費

### 4KBが選ばれた理由

4KB は、以下の理由でちょうど良いサイズでした

| 観点                   | 4KB の利点                                  |
| ---------------------- | ------------------------------------------- |
| ページテーブルのサイズ | 32 ビット時代に管理可能なサイズ             |
| ディスクとの相性       | ディスクのブロックサイズ（512B〜4KB）と整合 |
| 内部断片化             | 平均 2KB の無駄（統計的な期待値）           |
| 2 のべき乗             | アドレス計算が高速（ビットシフトで可能）    |

### 2のべき乗である理由

4KB = 4096 = 2<sup>12</sup> です

仮想アドレスは、「ページ番号」と「ページ内オフセット」に分解されます

```
仮想アドレス（32ビットの例）
┌────────────────────┬────────────┐
│  ページ番号（20ビット）│ オフセット（12ビット）│
└────────────────────┴────────────┘
```

ページサイズが 2<sup>12</sup> = 4096 なので、下位 12 ビットがオフセット、残りがページ番号になります

<strong>ビット演算による高速化</strong>

ページサイズが 2 のべき乗であるため、アドレス変換はビット演算だけで行えます

<strong>ビット演算とは</strong>

ビット演算は、数値を 2 進数として直接操作する方法です

CPU にとって最も基本的で高速な命令です

- `>> 12`：右に 12 ビットずらす（2<sup>12</sup> = 4096 で割るのと同じ）
- `& 0xFFF`：下位 12 ビットだけを残す（4096 で割った余りと同じ）

<strong>具体例で見てみる</strong>

```
仮想アドレス: 0x12345678（10進数で 305,419,896）

■ ステップ1：ページ番号を取り出す
  0x12345678 >> 12 = 0x12345
  （右に 12 ビットずらすと、下位 12 ビットが消える）

■ ステップ2：オフセットを取り出す
  0x12345678 & 0xFFF = 0x678
  （下位 12 ビットだけを残す = ページ内の位置）

■ ステップ3：物理アドレスを構築
  （TLB で 0x12345 → 0xABCDE と変換された場合）
  (0xABCDE << 12) | 0x678 = 0xABCDE678
```

<strong>なぜ割り算より速いのか</strong>

割り算は CPU にとって重い処理です（数十クロック）

一方、ビットシフトは 1 クロックで完了します

メモリアクセスは頻繁に発生するため、この差が積み重なって大きな性能差になります

---

## ページテーブルの仕組み

### なぜページテーブルが必要か

仮想アドレスを物理アドレスに変換するには、対応表が必要です

この対応表が<strong>ページテーブル</strong>です

### 単純なページテーブルの問題

32 ビットの仮想アドレス空間（4GB）を 4KB ページで管理すると

- ページ数 = 4GB ÷ 4KB = 1,048,576 ページ
- 各エントリが 4 バイトなら、ページテーブルは 4MB

プロセスごとに 4MB のページテーブルが必要になり、メモリを大量消費します

### 多段ページテーブル

単純なページテーブルの問題を解決するために、<strong>多段ページテーブル</strong>が使われます

<strong>なぜ多段にするのか</strong>

プロセスは通常、アドレス空間全体を使いません

```
典型的なプロセスのメモリ配置

アドレス空間（4GB）
┌────────────┐ 0xFFFFFFFF
│ カーネル領域 │  ← 使われる
├────────────┤
│   未使用    │  ← 大部分は空
│            │
├────────────┤
│  スタック   │  ← 使われる（小）
├────────────┤
│   未使用    │  ← 空
├────────────┤
│   ヒープ    │  ← 使われる（可変）
├────────────┤
│   コード    │  ← 使われる（小）
└────────────┘ 0x00000000
```

単純なページテーブルでは、未使用領域も含めて全エントリを確保する必要がありました

多段ページテーブルでは、<strong>使用している領域のテーブルだけ</strong>を作成します

```
仮想アドレス（32ビット、2段の例）
┌──────────────┬──────────────┬────────────┐
│ 第1段（10ビット）│ 第2段（10ビット）│ オフセット（12ビット）│
└──────────────┴──────────────┴────────────┘
```

| 項目            | サイズ                                   |
| --------------- | ---------------------------------------- |
| 第 1 段テーブル | 1024 エントリ × 4B = 4KB（常に存在）     |
| 第 2 段テーブル | 1024 エントリ × 4B = 4KB（必要な分だけ） |

第 1 段は常に存在しますが、第 2 段は<strong>実際に使われている領域だけ</strong>作成されます

これにより、4MB 必要だったテーブルが、数十 KB で済む場合もあります

### 64ビット環境

64 ビット環境（x86_64）では、4 段または 5 段のページテーブルが使われます

```
仮想アドレス（48ビット使用、4段の例）
┌─────┬─────┬─────┬─────┬────────────┐
│ PML4│ PDP │ PD  │ PT  │ オフセット    │
│ 9bit│ 9bit│ 9bit│ 9bit│   12bit      │
└─────┴─────┴─────┴─────┴────────────┘
```

| 名前 | 正式名称               | 説明    |
| ---- | ---------------------- | ------- |
| PML4 | Page Map Level 4       | 第 4 段 |
| PDP  | Page Directory Pointer | 第 3 段 |
| PD   | Page Directory         | 第 2 段 |
| PT   | Page Table             | 第 1 段 |

---

## TLBとは

### なぜTLBが必要なのか

多段ページテーブルを使うと、1 回のメモリアクセスに対して複数回のテーブル参照が必要です

4 段なら 4 回のメモリアクセスが追加で発生します

<strong>どのくらい遅くなるか</strong>

具体的な数値で考えてみましょう

| 状況             | 追加のメモリアクセス | 合計アクセス時間（概算）     |
| ---------------- | -------------------- | ---------------------------- |
| TLB ヒット       | 0 回                 | 約 100 ナノ秒（メモリ 1 回） |
| TLB ミス（4 段） | 4 回                 | 約 500 ナノ秒（メモリ 5 回） |

TLB がなければ、<strong>すべてのメモリアクセスが 5 倍遅くなる</strong>ことになります

これがキャッシュ（TLB）が必要な理由です

### TLB（Translation Lookaside Buffer）

この問題を解決するのが<strong>TLB</strong>です

TLB は、最近使ったページテーブルエントリをキャッシュする、CPU 内部の高速メモリです

```
TLB（キャッシュ）
┌──────────────┬──────────────┐
│ 仮想ページ番号 │ 物理ページ番号 │
├──────────────┼──────────────┤
│ 0x1234       │ 0xABCD       │
│ 0x1235       │ 0xABCE       │
│ ...          │ ...          │
└──────────────┴──────────────┘
```

### TLBの動作

1. 仮想アドレスにアクセス
2. TLB を検索
   - <strong>TLB ヒット</strong>：物理アドレスが即座に判明
   - <strong>TLB ミス</strong>：ページテーブルを参照し、TLB を更新

TLB のヒット率は通常 99% 以上であり、ほとんどのアクセスは高速に処理されます

### TLBとページサイズの関係

TLB のエントリ数は<strong>ハードウェアで固定</strong>されています

典型的な TLB サイズ（x86_64 の例）

| TLB の種類              | エントリ数         |
| ----------------------- | ------------------ |
| L1 DTLB（4KB ページ用） | 64 エントリ        |
| L1 DTLB（2MB ページ用） | 32 エントリ        |
| L2 TLB                  | 512〜1536 エントリ |

（実際のエントリ数は CPU アーキテクチャやモデルにより異なります）

同じエントリ数でも、ページサイズが大きいほど広い範囲をカバーできます

| ページサイズ | エントリ数 | カバー範囲 |
| ------------ | ---------- | ---------- |
| 4KB          | 64         | 256KB      |
| 2MB          | 32         | 64MB       |

<strong>大量のメモリを扱う場合の問題</strong>

データベースや仮想マシンなど、数 GB 以上のメモリを連続アクセスするアプリケーションでは、4KB ページだと TLB ミスが頻発します

```
例：10GB のメモリを走査

4KB ページの場合
  10GB ÷ 4KB = 約 260 万ページ
  64 エントリの TLB では全くカバーできない

2MB ページの場合
  10GB ÷ 2MB = 約 5,000 ページ
  TLB ミスが大幅に減少
```

これが Huge Pages が効果的な理由です

---

## Huge Pages

### 通常のページの限界

現代のシステムでは、メモリが数十〜数百 GB になることがあります

4KB ページだけでは、以下の問題が発生します

- ページテーブルが巨大になる
- TLB ミスが増加する

### Huge Pages とは

<strong>Huge Pages</strong>は、通常より大きなページサイズを使う機能です

| アーキテクチャ | 通常ページ | Huge Page |
| -------------- | ---------- | --------- |
| x86_64         | 4KB        | 2MB、1GB  |
| ARM64          | 4KB        | 2MB、1GB  |

### Huge Pages の利点

- <strong>TLB 効率の向上</strong>：1 エントリでより広い範囲をカバー
- <strong>ページテーブルの縮小</strong>：管理するページ数が減る
- <strong>ページフォルトの減少</strong>：1 回のフォルトで大きな領域を確保

### Huge Pages のデメリット

Huge Pages は万能ではありません

以下のような問題があります

<strong>内部断片化の増大</strong>

| ページサイズ | 1.5MB 必要な場合         | 無駄になるメモリ |
| ------------ | ------------------------ | ---------------- |
| 4KB          | 384 ページ × 4KB = 1.5MB | ほぼ 0           |
| 2MB          | 1 ページ × 2MB = 2MB     | 512KB（25%）     |

小さなメモリ割り当てが多いアプリケーションでは、メモリの無駄が増えます

<strong>メモリの断片化問題</strong>

2MB の連続した空き領域が必要なため、メモリが断片化していると確保に失敗します

```
断片化したメモリの例（■=使用中、□=空き）

■□■□■□■□■□■□■□■□■□■□■□■□■□■□

4KB ページなら確保可能（□が多数ある）
2MB ページは確保不可（連続した □ が足りない）
```

<strong>THP（Transparent Huge Pages）のオーバーヘッド</strong>

THP を有効にすると、カーネルがバックグラウンドで以下の処理を行います

| 処理       | 内容                                            |
| ---------- | ----------------------------------------------- |
| compaction | 断片化したメモリを整理して連続領域を確保        |
| khugepaged | 4KB ページを 2MB ページに統合（CPU 時間を消費） |

これらの処理がレイテンシのスパイクを引き起こすことがあります

特にレイテンシに敏感なアプリケーション（データベース、Redis など）では、THP を無効にすることが推奨される場合があります

```bash
# Redis の公式ドキュメントでは THP の無効化を推奨
echo never > /sys/kernel/mm/transparent_hugepage/enabled
```

<strong>いつ Huge Pages を使うべきか</strong>

| ユースケース                                  | 推奨                  |
| --------------------------------------------- | --------------------- |
| 大規模データベース（Oracle、PostgreSQL など） | 明示的な Huge Pages   |
| 仮想化（KVM、QEMU）                           | 明示的な Huge Pages   |
| レイテンシ重視のアプリ（Redis、HFT）          | THP 無効              |
| 一般的なサーバー                              | THP（madvise モード） |
| デスクトップ                                  | THP（always）         |

### Huge Pages の使い方

<strong>Transparent Huge Pages（THP）</strong>

THP は、カーネルが<strong>自動的に</strong> Huge Pages を使用する機能です

```bash
# THP の状態を確認
cat /sys/kernel/mm/transparent_hugepage/enabled
```

出力例

```
[always] madvise never
```

`[ ]` で囲まれているのが現在の設定です

<strong>3 つのモード</strong>

| モード  | 動作                                                               |
| ------- | ------------------------------------------------------------------ |
| always  | 常に Huge Pages の使用を試みる（割り当て待ちが発生する可能性あり） |
| madvise | madvise(MADV_HUGEPAGE) を呼び出した領域のみ適用                    |
| never   | THP を無効化                                                       |

<strong>設定方法</strong>

```bash
# madvise モードに設定
echo madvise > /sys/kernel/mm/transparent_hugepage/enabled
```

<strong>明示的な Huge Pages</strong>

アプリケーションが MAP_HUGETLB フラグで明示的に要求します

```c
void *mem = mmap(NULL, size, PROT_READ | PROT_WRITE,
                 MAP_PRIVATE | MAP_ANONYMOUS | MAP_HUGETLB, -1, 0);
```

<strong>権限要件</strong>

MAP_HUGETLB を使用するには、以下のいずれかが必要です

| 条件                         | 説明                             |
| ---------------------------- | -------------------------------- |
| CAP_IPC_LOCK ケーパビリティ  | メモリをロックする権限           |
| hugetlb_shm_group のメンバー | システム管理者が設定したグループ |

一般ユーザーで使用する場合は、グループへの追加が必要です

```bash
# hugetlb_shm_group の確認
cat /proc/sys/vm/hugetlb_shm_group
```

### Huge Pages の確認と設定

<strong>現在の状態を確認</strong>

```bash
# Huge Pages の統計
grep -i huge /proc/meminfo
```

出力例

```
AnonHugePages:    524288 kB    ← THP で使用中
HugePages_Total:       0       ← 予約済み Huge Pages の総数
HugePages_Free:        0       ← 未使用の Huge Pages
HugePages_Rsvd:        0       ← 予約済みだが未割り当て
HugePages_Surp:        0       ← 超過分の Huge Pages
Hugepagesize:       2048 kB    ← デフォルトの Huge Page サイズ
```

<strong>Huge Pages の事前確保</strong>

MAP_HUGETLB を使用するには、事前に Huge Pages を確保しておく必要があります

```bash
# 現在の確保数を確認
cat /proc/sys/vm/nr_hugepages

# 100 ページ（200MB）を確保
echo 100 > /proc/sys/vm/nr_hugepages
```

<strong>永続的な設定</strong>

起動時に確保するには、sysctl.conf に設定します

```bash
# /etc/sysctl.conf に追加
vm.nr_hugepages = 100
```

---

## ページサイズの確認方法

### コマンドラインで確認

```bash
# getconf コマンド
getconf PAGESIZE

# または
getconf PAGE_SIZE
```

### C プログラムで確認

```c
#include <unistd.h>
#include <stdio.h>

int main(void) {
    long page_size = sysconf(_SC_PAGESIZE);
    printf("Page size: %ld bytes\n", page_size);
    return 0;
}
```

### /proc から確認

```bash
# Huge Page のサイズ
grep Hugepagesize /proc/meminfo
```

---

## まとめ

<strong>ページサイズが4KBである理由</strong>

| 観点             | 説明                             |
| ---------------- | -------------------------------- |
| 歴史的経緯       | 1980 年代の VAX-11 に由来        |
| トレードオフ     | 管理コストと内部断片化のバランス |
| 2のべき乗        | アドレス計算が高速               |
| ディスクとの相性 | ブロックサイズと整合             |

<strong>覚えておくこと</strong>

| ポイント                     | 説明                                 |
| ---------------------------- | ------------------------------------ |
| ページはメモリ管理の最小単位 | カーネルはページ単位でメモリを扱う   |
| ページテーブルは多段構造     | メモリ節約のため、必要な部分だけ作成 |
| TLBが変換を高速化            | キャッシュにより 99% 以上のヒット率  |
| Huge Pages で効率向上        | 大規模メモリ環境では有効             |

---

## 参考資料

<strong>Linux マニュアル</strong>

- [getpagesize(2) - Linux manual page](https://man7.org/linux/man-pages/man2/getpagesize.2.html)
  - ページサイズの取得
- [mmap(2) - Linux manual page](https://man7.org/linux/man-pages/man2/mmap.2.html)
  - MAP_HUGETLB フラグ

<strong>Linux カーネルドキュメント</strong>

- [Transparent Hugepage Support - kernel.org](https://www.kernel.org/doc/html/latest/admin-guide/mm/transhuge.html)
  - THP の詳細
- [HugeTLB Pages - kernel.org](https://www.kernel.org/doc/html/latest/admin-guide/mm/hugetlbpage.html)
  - Huge Pages の設定と使い方

<strong>本編との関連</strong>

- [03-virtual-memory](../03-virtual-memory.md)
  - ページングの基本
