<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# psのSTAT列は何を意味するのか

## はじめに

[04-process-management](../04-process-management.md) の「プロセスの状態」で、プロセスには R、S、D などの状態があることを学びました

```bash
ps aux
```

このコマンドを実行すると、STAT 列に `Ss`、`R+`、`D` といった謎の文字が表示されます

```
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.0   2564  1536 ?        Ss   10:00   0:00 /sbin/init
root       123  0.0  0.0   4096  2048 ?        D    10:01   0:00 [kworker/u4:0]
user       456  0.0  0.0   4096  2048 pts/0    R+   10:02   0:00 ps aux
```

この `Ss`、`D`、`R+` は何を意味しているのでしょうか？

特に `D` 状態のプロセスが増えるとシステムが重くなり、場合によっては操作不能になることがあります

このドキュメントでは、STAT 列の読み方と、各状態の意味を詳しく説明します

---

## 目次

- [STAT列の構造](#stat列の構造)
- [主要な状態コード](#主要な状態コード)
- [追加フラグ](#追加フラグ)
- [D状態の危険性](#d状態の危険性)
- [ゾンビプロセスの対処](#ゾンビプロセスの対処)
- [状態の確認方法](#状態の確認方法)
- [まとめ](#まとめ)
- [参考資料](#参考資料)

---

## STAT列の構造

### 基本構造

STAT 列は、<strong>状態コード</strong>と<strong>追加フラグ</strong>の組み合わせで構成されています

```
STAT = 状態コード + 追加フラグ（0個以上）

例：
Ss  = S（休止中）+ s（セッションリーダー）
R+  = R（実行中）+ +（フォアグラウンド）
D<  = D（I/O待ち）+ <（高優先度）
```

### 最初の文字が状態コード

最初の 1 文字は、プロセスの<strong>現在の状態</strong>を表します

```
R = 実行中 / 実行可能
S = 割り込み可能な休止
D = 割り込み不可能な休止
T = 停止中
Z = ゾンビ
```

### 2文字目以降が追加フラグ

2 文字目以降は、プロセスの<strong>属性</strong>を表す追加フラグです

```
s = セッションリーダー
+ = フォアグラウンドプロセスグループ
< = 高優先度
N = 低優先度（nice）
l = マルチスレッド
```

---

## 主要な状態コード

### R（Running / Runnable）

<strong>実行中</strong>または<strong>実行可能</strong>な状態です

| 状況     | 説明                       |
| -------- | -------------------------- |
| 実行中   | 現在 CPU を使用している    |
| 実行可能 | CPU の割り当てを待っている |

CPU が 1 つしかないシステムでも、複数のプロセスが R 状態になることがあります

実際に CPU を使っているのは 1 つだけで、他は「実行可能だが順番待ち」の状態です

### S（Sleeping - Interruptible）

<strong>割り込み可能な休止</strong>状態です

何かのイベント（入力、タイマー、シグナルなど）を待っています

| 特徴               | 説明                       |
| ------------------ | -------------------------- |
| シグナルで起こせる | SIGKILL などで強制終了可能 |
| 最も一般的な状態   | 多くのプロセスは S 状態    |
| CPU を消費しない   | イベントまで休止           |

```bash
# S 状態のプロセスを表示
ps aux | awk '$8 ~ /S/'
```

### D（Sleeping - Uninterruptible）

<strong>割り込み不可能な休止</strong>状態です

これは<strong>最も注意が必要な状態</strong>です

| 特徴                 | 説明                     |
| -------------------- | ------------------------ |
| シグナルで起こせない | SIGKILL でも終了できない |
| 通常は短時間         | ディスク I/O の完了待ち  |
| 長時間続くと問題     | ストレージ障害の可能性   |

詳細は後述の「D 状態の危険性」を参照してください

### T（Stopped）

<strong>停止</strong>状態です

シグナルによって一時停止しています

| シグナル | 発生条件                               |
| -------- | -------------------------------------- |
| SIGSTOP  | プログラムからの明示的な停止要求       |
| SIGTSTP  | Ctrl+Z（端末からの停止要求）           |
| SIGTTIN  | バックグラウンドプロセスの端末入力試行 |
| SIGTTOU  | バックグラウンドプロセスの端末出力試行 |

SIGCONT で再開できます

```bash
# プロセスを停止
kill -STOP 12345

# プロセスを再開
kill -CONT 12345
```

### t（Tracing stop）

<strong>デバッガによるトレース停止</strong>状態です

gdb などのデバッガがプロセスを停止させています

```bash
# gdb でプロセスにアタッチ
gdb -p 12345
```

### Z（Zombie）

<strong>ゾンビ</strong>状態です

プロセスは終了したが、親プロセスがまだ `wait()` を呼んでいない状態です

| 特徴                           | 説明                             |
| ------------------------------ | -------------------------------- |
| リソースは解放済み             | メモリ、ファイルは閉じられている |
| PID テーブルのエントリだけ残る | 終了コードを親に渡すため         |
| 親が wait() すれば消える       | 正常な動作                       |

詳細は後述の「ゾンビプロセスの対処」を参照してください

### I（Idle）

<strong>カーネルスレッドのアイドル</strong>状態です（Linux 4.14 以降）

| 特徴                         | 説明                             |
| ---------------------------- | -------------------------------- |
| カーネルスレッド専用         | ユーザープロセスでは使用されない |
| ロードアベレージに含まれない | D 状態と異なり負荷計算から除外   |

---

## 追加フラグ

### 一覧

| フラグ | 意味                             |
| ------ | -------------------------------- |
| <      | 高優先度（nice 値が負）          |
| N      | 低優先度（nice 値が正）          |
| L      | ページがメモリにロックされている |
| s      | セッションリーダー               |
| l      | マルチスレッド（小文字の L）     |
| +      | フォアグラウンドプロセスグループ |

### 組み合わせ例

| STAT | 意味                       |
| ---- | -------------------------- |
| Ss   | 休止中、セッションリーダー |
| S+   | 休止中、フォアグラウンド   |
| R+   | 実行中、フォアグラウンド   |
| Sl   | 休止中、マルチスレッド     |
| D<   | I/O 待ち、高優先度         |
| SN   | 休止中、低優先度（nice）   |
| Z+   | ゾンビ、フォアグラウンド   |

---

## D状態の危険性

### なぜD状態は特別か

D 状態（Uninterruptible Sleep）は、<strong>シグナルを受け付けない</strong>唯一の状態です

```bash
# D 状態のプロセスは SIGKILL でも終了できない
kill -9 12345  # 効果なし
```

<strong>なぜシグナルを受け付けないのか</strong>

D 状態がシグナルを受け付けない理由は、<strong>データの一貫性を守る</strong>ためです

例えば、ファイルをディスクに書き込んでいる最中を考えてください

```
1. プロセスが「100バイト書き込む」と指示
2. カーネルが 50 バイト目まで書き込んだ
3. ← ここで SIGKILL を受け付けたら？
4. ファイルは「50 バイトしか書かれていない壊れた状態」になる
```

これを防ぐため、カーネルは I/O 操作中のプロセスを「割り込み不可能」にします

<strong>操作が完了するか、失敗するまで待つ</strong>ことで、データの整合性を保証しています

### カーネル内部での実装

カーネルは、プロセスの状態を `task_struct` 構造体の `__state` フィールドで管理しています

| 状態定数             | ps での表示 | シグナル受付 |
| -------------------- | ----------- | ------------ |
| TASK_RUNNING         | R           | 可           |
| TASK_INTERRUPTIBLE   | S           | 可           |
| TASK_UNINTERRUPTIBLE | D           | 不可         |

<strong>シグナル配送時の状態チェック</strong>

カーネルがシグナルを配送するとき、まずプロセスの状態をチェックします

```c
/* シグナル配送の簡略化されたフロー */
if (task->__state == TASK_UNINTERRUPTIBLE) {
    /* シグナルを保留キューに入れるが、プロセスは起こさない */
    /* プロセスが自発的に起きるまでシグナルは処理されない */
}
```

TASK_INTERRUPTIBLE なら「起こして」シグナルを処理させますが、TASK_UNINTERRUPTIBLE なら何もしません

<strong>wait queue による状態遷移</strong>

ドライバやファイルシステムは、I/O 完了を待つとき `wait queue` を使います

```c
/* 割り込み可能な待機（S 状態） */
wait_event_interruptible(queue, condition);
/* → シグナルで起こされると -ERESTARTSYS を返す */

/* 割り込み不可能な待機（D 状態） */
wait_event(queue, condition);
/* → condition が true になるまで絶対に起きない */
```

`wait_event()` を使うと、プロセスは TASK_UNINTERRUPTIBLE に設定され、条件が満たされるまで起きません

<strong>なぜドライバは wait_event() を選ぶのか</strong>

シグナルによる中断を許可すると、ドライバは「処理の途中で戻る」コードパスを実装する必要があります

| 選択                     | メリット             | デメリット                   |
| ------------------------ | -------------------- | ---------------------------- |
| wait_event_interruptible | SIGKILL で終了できる | 中断処理のコードが複雑になる |
| wait_event（D 状態）     | 実装がシンプル       | プロセスを強制終了できない   |

多くのドライバは、短時間で完了する I/O であれば、実装の単純さを優先して `wait_event()` を使います

参考：[kernel.org - Wait queues](https://www.kernel.org/doc/html/latest/kernel-hacking/hacking.html#wait-queues-and-wake-functions)

### D状態の正常なケース

通常、D 状態は<strong>非常に短時間</strong>です

| 操作           | 説明                                     |
| -------------- | ---------------------------------------- |
| ディスク I/O   | ブロックデバイスへの読み書き             |
| NFS アクセス   | ネットワークファイルシステムへのアクセス |
| ページフォルト | スワップからのページ読み込み             |

これらの操作は通常ミリ秒単位で完了します

### D状態が長時間続く場合

D 状態が数秒以上続く場合、以下の問題が考えられます

| 原因               | 症状                         |
| ------------------ | ---------------------------- |
| ディスク障害       | I/O が完了しない             |
| NFS サーバーダウン | ネットワーク越しの応答がない |
| カーネルバグ       | ドライバの問題               |
| iSCSI / FC 障害    | ストレージネットワークの問題 |

<strong>身近な例</strong>

| 状況                         | 発生するケース                                                                         |
| ---------------------------- | -------------------------------------------------------------------------------------- |
| USB ストレージの抜き差し     | 書き込み中に USB メモリを抜くと、そのファイルにアクセスしていたプロセスが D 状態になる |
| HDD の不良セクタ             | 壊れた領域を読み込もうとして、リトライを繰り返す                                       |
| 仮想マシンのスナップショット | スナップショット作成中にディスク I/O が一時停止する                                    |
| 遅いネットワークドライブ     | VPN 越しの共有フォルダへのアクセスがタイムアウト待ち                                   |

### D状態プロセスの影響

D 状態のプロセスは<strong>ロードアベレージに加算</strong>されます

<strong>ロードアベレージとは</strong>

ロードアベレージは「実行を待っているプロセスの数」の平均です（詳細は [load-average.md](./load-average.md) を参照）

Linux では、D 状態のプロセスも「実行待ち」としてカウントされます

これは、I/O 待ちのプロセスも「仕事をしたいのに待たされている」という意味で負荷の一部と見なすためです

```bash
# ロードアベレージを確認
uptime

# 出力例（D 状態が多いと値が高くなる）
 10:00:00 up 1 day,  0:00,  2 users,  load average: 15.00, 12.00, 8.00
```

<strong>CPU 使用率とロードアベレージの乖離</strong>

CPU 使用率が低いのにロードアベレージが高い場合、D 状態のプロセスが原因の可能性があります

| 状況             | CPU 使用率 | ロードアベレージ | 原因                 |
| ---------------- | ---------- | ---------------- | -------------------- |
| 正常             | 80%        | 4.0（4コア）     | CPU が忙しい         |
| I/O ボトルネック | 10%        | 15.0             | D 状態プロセスが多い |

### D状態の調査方法

```bash
# D 状態のプロセスを一覧表示
ps aux | awk '$8 == "D" || $8 ~ /^D/'

# カーネルスタックを確認（root 権限が必要）
cat /proc/12345/stack

# または
echo w > /proc/sysrq-trigger  # すべての D 状態プロセスのスタックをカーネルログに出力
dmesg | tail -50
```

---

## ゾンビプロセスの対処

### ゾンビとは

<strong>ゾンビプロセス</strong>は、終了したが親プロセスに回収されていないプロセスです

```bash
# ゾンビプロセスを確認
ps aux | awk '$8 == "Z" || $8 ~ /^Z/'
```

### なぜゾンビは存在するのか

ゾンビには重要な目的があります

<strong>終了コードを親に渡すため</strong>です

```c
pid_t child = fork();
if (child == 0) {
    exit(42);  /* 子プロセスが終了コード 42 で終了 */
}

/* 親プロセスが wait() を呼ぶまで、子はゾンビ状態 */
int status;
wait(&status);  /* ここで終了コード 42 を取得 */
```

### ゾンビの問題

ゾンビ自体は<strong>リソースをほとんど消費しません</strong>

しかし、以下の問題があります

| 問題             | 説明                                |
| ---------------- | ----------------------------------- |
| PID の枯渇       | 大量のゾンビは PID テーブルを圧迫   |
| 親プロセスのバグ | wait() を忘れているプログラムの兆候 |

### ゾンビの対処法

<strong>1. 親プロセスを修正する</strong>

親プロセスが `wait()` を呼ぶようにプログラムを修正します

<strong>2. 親プロセスを終了する</strong>

親プロセスが終了すると、ゾンビは init（PID 1）に引き継がれます

init は定期的に `wait()` を呼ぶので、ゾンビは回収されます

```bash
# ゾンビの親プロセスを特定
ps -o pid,ppid,stat,comm | grep Z

# 親プロセスを終了（慎重に）
kill 親のPID
```

<strong>3. シグナルで親にヒントを与える</strong>

SIGCHLD を親に送ると、wait() を呼ぶきっかけになることがあります

```bash
kill -SIGCHLD 親のPID
```

---

## 状態の確認方法

### ps コマンド

```bash
# 全プロセスの状態を表示
ps aux

# 特定の状態だけ表示
ps aux | awk '$8 ~ /D/'   # D 状態
ps aux | awk '$8 ~ /Z/'   # ゾンビ
ps aux | awk '$8 ~ /T/'   # 停止中
```

### /proc/[pid]/stat

```bash
# 3番目のフィールドが状態コード
cat /proc/self/stat | awk '{print $3}'
```

### /proc/[pid]/status

```bash
# State 行を確認
grep State /proc/self/status
```

出力例

```
State:  R (running)
```

### top / htop

リアルタイムで状態を監視できます

```bash
top -d 1  # 1秒間隔で更新

# S 列が状態コード
```

---

## まとめ

<strong>主要な状態コード</strong>

| コード | 名前                        | 説明                     |
| ------ | --------------------------- | ------------------------ |
| R      | Running                     | 実行中または実行可能     |
| S      | Sleeping（Interruptible）   | シグナルで起こせる休止   |
| D      | Sleeping（Uninterruptible） | シグナルで起こせない休止 |
| T      | Stopped                     | シグナルで停止中         |
| Z      | Zombie                      | 終了済み、親が未回収     |

<strong>覚えておくこと</strong>

| ポイント                       | 説明                                     |
| ------------------------------ | ---------------------------------------- |
| D 状態は要注意                 | 長時間続くとストレージ障害の可能性       |
| D 状態はロードアベレージに影響 | CPU 使用率が低いのに負荷が高い原因       |
| ゾンビは親の責任               | 親プロセスが wait() を呼べば消える       |
| 追加フラグで属性が分かる       | s=セッションリーダー、+=フォアグラウンド |

---

## 参考資料

<strong>Linux マニュアル</strong>

- [ps(1) - Linux manual page](https://man7.org/linux/man-pages/man1/ps.1.html)
  - STAT 列の詳細
- [proc(5) - Linux manual page](https://man7.org/linux/man-pages/man5/proc.5.html)
  - /proc/[pid]/stat の形式

<strong>本編との関連</strong>

- [04-process-management](../04-process-management.md)
  - プロセスの状態、ゾンビプロセス
- [05-scheduler](../05-scheduler.md)
  - R 状態とスケジューリング
