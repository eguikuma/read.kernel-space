<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# 03-virtual-memory：仮想メモリの仕組み

## はじめに

[02-syscall](./02-syscall.md) では、ユーザー空間からカーネルへの「扉」であるシステムコールを学びました

- システムコールの仕組み
- ライブラリ関数とシステムコールの違い
- strace でシステムコールを観察する方法
- vDSO による高速化

しかし、1つ疑問が残ります

プログラムが `malloc()` でメモリを確保したとき、カーネルは何をしているのでしょうか？

また、複数のプログラムが同時に動いているとき、なぜメモリが混ざらないのでしょうか？

このページでは、カーネルがプロセスごとに独立したメモリ空間を提供する仕組み、<strong>仮想メモリ</strong>について学びます

### 日常の例え

仮想メモリを「マンションの部屋番号」に例えてみましょう

マンションの各部屋には「101号室」「102号室」のような番号があります

<strong>仮想アドレス</strong>は、この「部屋番号」に相当します

各プログラム（住人）は、自分の部屋番号（仮想アドレス）を使ってメモリにアクセスします

しかし、実際の建物（物理メモリ）では、部屋は別の場所にあるかもしれません

<strong>カーネル</strong>は「マンションの管理人」として、部屋番号と実際の場所の対応表（ページテーブル）を管理しています

- プログラム A の「0x1000番地」とプログラム B の「0x1000番地」は、物理的には別の場所
- 管理人（カーネル）が、各プログラムのアクセスを正しい場所に案内する
- プログラムは自分の部屋番号だけを知っていればよく、物理的な場所を意識する必要がない

### このページで学ぶこと

このページでは、以下の概念を学びます

- <strong>仮想メモリとは何か</strong>
  - なぜ仮想メモリが必要なのか
  - 仮想アドレスと物理アドレスの違い
- <strong>アドレス空間の構造</strong>
  - テキスト、データ、ヒープ、スタック領域
- <strong>ページングの仕組み</strong>
  - ページとは何か
  - ページテーブルによるアドレス変換
- <strong>/proc/self/maps</strong>
  - プロセスのメモリマップを観察する方法
- <strong>mmap() システムコール</strong>
  - メモリマッピングの仕組み
  - 無名マッピングとファイルマッピング
- <strong>メモリ保護</strong>
  - mprotect() による保護属性の変更
- <strong>メモリのロック</strong>
  - mlock() によるスワップアウトの防止

---

## 目次

1. [仮想メモリとは何か](#仮想メモリとは何か)
2. [アドレス空間の構造](#アドレス空間の構造)
3. [ページングの仕組み](#ページングの仕組み)
4. [/proc/self/maps でメモリマップを観察](#procselfmaps-でメモリマップを観察)
5. [mmap() によるメモリマッピング](#mmap-によるメモリマッピング)
6. [メモリ保護（mprotect）](#メモリ保護mprotect)
7. [メモリのロック（mlock）](#メモリのロックmlock)
8. [/proc/self/smaps で詳細情報を取得](#procselfsmaps-で詳細情報を取得)
9. [用語集](#用語集)
10. [参考資料](#参考資料)

---

## 仮想メモリとは何か

### なぜ仮想メモリが必要なのか

物理メモリ（RAM）を直接使うと、以下の問題が発生します

<strong>1. メモリの衝突</strong>

複数のプログラムが同時に動くと、同じアドレスを使おうとして衝突します

<strong>2. セキュリティの問題</strong>

あるプログラムが他のプログラムのメモリを読み書きできてしまいます

<strong>3. メモリの断片化</strong>

プログラムの起動と終了を繰り返すと、空きメモリが細切れになります

### 仮想メモリの解決策

<strong>仮想メモリ</strong>は、これらの問題を解決する仕組みです

Linux カーネルのドキュメント（Memory Management）では、仮想メモリについて以下のように説明されています

> Each process has its own virtual address space, which is mapped to physical memory by the kernel.

> 各プロセスは独自の仮想アドレス空間を持ち、カーネルによって物理メモリにマップされます

仮想メモリの利点

| 利点               | 説明                                             |
| ------------------ | ------------------------------------------------ |
| プロセスの分離     | 各プロセスが独立したアドレス空間を持つ           |
| メモリ保護         | 他のプロセスのメモリにアクセスできない           |
| 効率的なメモリ利用 | 必要なときだけ物理メモリを割り当てる             |
| 柔軟なメモリ配置   | 連続した仮想アドレスが物理的には離れていてもよい |

### 仮想アドレスと物理アドレス

| 種類           | 説明                                   |
| -------------- | -------------------------------------- |
| 仮想アドレス   | プログラムから見えるアドレス           |
| 物理アドレス   | 実際の RAM 上のアドレス                |
| アドレス変換   | 仮想アドレスを物理アドレスに変換する   |
| MMU            | アドレス変換を行うハードウェア         |
| ページテーブル | 仮想と物理の対応関係を記録したテーブル |

<strong>MMU（Memory Management Unit）</strong>は、CPU に内蔵されたハードウェアで、仮想アドレスから物理アドレスへの変換を高速に行います

---

## アドレス空間の構造

プロセスの仮想アドレス空間は、いくつかの領域に分かれています

### 主要な領域

| 領域         | 説明                                  | 成長方向   |
| ------------ | ------------------------------------- | ---------- |
| テキスト領域 | プログラムの機械語コード              | 固定       |
| データ領域   | 初期化されたグローバル変数            | 固定       |
| BSS 領域     | 初期化されていないグローバル変数      | 固定       |
| ヒープ領域   | malloc() などで動的に確保されるメモリ | 上方向     |
| スタック領域 | 関数のローカル変数や戻りアドレス      | 下方向     |
| mmap 領域    | mmap() でマップされたメモリやファイル | 設定による |

### アドレス空間のレイアウト

一般的な Linux（x86_64）では、以下のような配置になっています

```
高いアドレス
┌─────────────────────┐
│ カーネル空間        │ ← ユーザーからはアクセス不可
├─────────────────────┤
│ スタック            │ ↓ 下方向に成長
│                     │
├─────────────────────┤
│ mmap 領域           │
│ （共有ライブラリ等）│
├─────────────────────┤
│                     │
│ ヒープ              │ ↑ 上方向に成長
├─────────────────────┤
│ BSS                 │
├─────────────────────┤
│ データ              │
├─────────────────────┤
│ テキスト            │
└─────────────────────┘
低いアドレス
```

### 各領域の詳細

<strong>テキスト領域（.text）</strong>

- プログラムの機械語コードが配置されます
- 読み取り専用（実行可能）です
- 複数プロセスで共有される場合があります

<strong>データ領域（.data）</strong>

- 初期化されたグローバル変数や静的変数が配置されます
- 読み書き可能です

<strong>BSS 領域（.bss）</strong>

- プログラマが明示的に初期値を指定していないグローバル変数が配置されます
- プログラム起動時にカーネルが 0 で初期化します
- 実行ファイルにはサイズ情報のみが含まれます（初期値が 0 なのでデータを保存する必要がない）

<strong>BSS が存在する歴史的背景</strong>

BSS は「Block Started by Symbol」の略で、初期のアセンブリ言語にまで遡る歴史ある概念です

なぜ BSS 領域が別に存在するのでしょうか？

理由は<strong>実行ファイルのサイズ最適化</strong>です

例えば、1MB の配列をグローバル変数として宣言した場合を考えます

```c
int large_array[262144];  /* 1MB（= 262144 × 4バイト） */
```

もし BSS 領域がなければ、この配列のデータ（すべて 0）を実行ファイルに含める必要があります

実行ファイルが 1MB 以上大きくなってしまいます

BSS 領域があれば、「1MB の領域が必要」という情報（数バイト）だけを実行ファイルに記録し、プログラム起動時にカーネルが 0 で初期化します

ディスク容量やネットワーク帯域が貴重だった時代には、この最適化は特に重要でした

<strong>ヒープ領域</strong>

- `malloc()`、`calloc()`、`realloc()` で確保されるメモリです
- 大きなメモリ確保では `mmap()` が使われることもあります
- `free()` で解放します

<strong>スタック領域</strong>

- 関数のローカル変数、引数、戻りアドレスが配置されます
- 関数呼び出しごとにスタックフレームが積まれます
- サイズに制限があります（`ulimit -s` で確認可能）

---

## ページングの仕組み

### ページとは

<strong>ページ</strong>は、メモリ管理の最小単位です

Linux カーネルのドキュメント（Memory Management）では、以下のように説明されています

> Memory is managed in fixed-size blocks called pages.

> メモリはページと呼ばれる固定サイズのブロックで管理されます

一般的な Linux では、ページサイズは <strong>4KB（4096 バイト）</strong>です

### ページサイズの確認方法

```bash
getconf PAGESIZE
```

または C プログラムで

```c
long page_size = sysconf(_SC_PAGESIZE);
```

### ページテーブル

<strong>ページテーブル</strong>は、仮想ページと物理ページの対応関係を記録したテーブルです

| 仮想ページ | 物理ページ | フラグ                 |
| ---------- | ---------- | ---------------------- |
| 0x1000     | 0xA000     | 読み取り可、実行可     |
| 0x2000     | 0xB000     | 読み取り可、書き込み可 |
| 0x3000     | なし       | 未割り当て             |

### ページフォルト

プログラムがまだ物理メモリに割り当てられていないページにアクセスすると、<strong>ページフォルト</strong>が発生します

カーネルはページフォルトを処理して

1. 必要なら物理ページを割り当てる
2. ページテーブルを更新する
3. プログラムの実行を再開する

これにより、実際に使うときまで物理メモリの割り当てを遅延できます（<strong>デマンドページング</strong>）

### デマンドページングの利点

デマンドページングは、なぜ物理メモリを節約できるのでしょうか？

具体例で考えてみましょう

<strong>例 1：大きな配列の部分的な使用</strong>

```c
int large_array[1000000];  /* 400万バイト（約4MB）を宣言 */
/* しかし、実際には最初の100要素しか使わない */
```

デマンドページングにより、実際にアクセスしたページ（最初の数ページ）だけに物理メモリが割り当てられます

<strong>例 2：fork() 後のコピーオンライト（Copy-on-Write）</strong>

`fork()` でプロセスを複製するとき、もし物理メモリを即座にコピーすると、大量のメモリと時間を消費します

代わりに、カーネルは以下のように動作します

1. `fork()` 直後は、親子で同じ物理ページを共有する（ページテーブルだけをコピー）
2. どちらかがページに書き込もうとすると、ページフォルトが発生
3. カーネルがその時点でページをコピーする
4. 書き込みを行ったプロセスは新しいページを使う

多くのプログラムは `fork()` の直後に `exec()` を呼び出すため、親のメモリ内容をほとんどコピーせずに済みます

この仕組みにより、`fork()` は非常に高速に動作します

ページングの詳しい仕組みは [appendices/page.md](./appendices/page.md) で学べます

---

## /proc/self/maps でメモリマップを観察

### /proc/self/maps とは

`/proc/self/maps` は、現在のプロセスのメモリマップを表示する疑似ファイルです

proc(5) の man ページには、こう書かれています

> A file containing the currently mapped memory regions and their access permissions.

> 現在マップされているメモリ領域とそのアクセス権限を含むファイル

### 出力形式

```
アドレス範囲           権限 オフセット デバイス inode パス名
7f8a12345000-7f8a12346000 r-xp 00000000 08:01 123456 /lib/libc.so.6
```

### フィールドの説明

| フィールド   | 説明                                           |
| ------------ | ---------------------------------------------- |
| アドレス範囲 | 開始アドレス-終了アドレス                      |
| 権限         | 4 文字固定フォーマット（下記参照）             |
| オフセット   | ファイルマッピングの場合、ファイル内の開始位置 |
| デバイス     | ファイルが存在するデバイスの識別番号           |
| inode        | ファイルの識別番号（0 は無名マッピング）       |
| パス名       | ファイル名または特殊領域名                     |

<strong>inode とは</strong>

inode（アイノード）は、ファイルシステム内でファイルを一意に識別する番号です

ファイル名とは別に、カーネルはこの番号でファイルを管理しています

### 権限フィールドの形式

権限は 4 文字で表され、各位置に意味があります

| 位置 | 意味                              |
| ---- | --------------------------------- |
| 1    | r（読み取り可）または -（不可）   |
| 2    | w（書き込み可）または -（不可）   |
| 3    | x（実行可）または -（不可）       |
| 4    | p（プライベート）または s（共有） |

具体例

| 権限 | 意味                                           |
| ---- | ---------------------------------------------- |
| r-xp | 読み取り可、書き込み不可、実行可、プライベート |
| rw-p | 読み取り可、書き込み可、実行不可、プライベート |
| r--s | 読み取りのみ、共有                             |

### 特殊領域名

| 名前    | 説明                      |
| ------- | ------------------------- |
| [heap]  | ヒープ領域                |
| [stack] | スタック領域              |
| [vdso]  | 仮想動的共有オブジェクト  |
| [vvar]  | vDSO が参照するデータ領域 |

### コマンドでの確認

```bash
cat /proc/self/maps
```

---

## mmap() によるメモリマッピング

### mmap() とは

`mmap()` は、メモリ領域をプロセスのアドレス空間にマップするシステムコールです

mmap(2) の man ページには、こう書かれています

> mmap() creates a new mapping in the virtual address space of the calling process.

> mmap() は呼び出しプロセスの仮想アドレス空間に新しいマッピングを作成します

### mmap() の主な用途

<strong>1. 無名マッピング（メモリ確保）</strong>

ファイルに関連付けられないメモリを確保します

```c
void *mem = mmap(NULL, size, PROT_READ | PROT_WRITE,
                 MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
```

<strong>2. ファイルマッピング</strong>

ファイルの内容をメモリ上に展開します

```c
void *mem = mmap(NULL, file_size, PROT_READ,
                 MAP_PRIVATE, fd, 0);
```

### mmap() のフラグ

| フラグ        | 説明                                       |
| ------------- | ------------------------------------------ |
| MAP_PRIVATE   | プライベートマッピング（コピーオンライト） |
| MAP_SHARED    | 共有マッピング（書き込みが他に見える）     |
| MAP_ANONYMOUS | 無名マッピング（ファイルなし）             |
| MAP_FIXED     | 指定したアドレスに必ずマップ               |

<strong>コピーオンライト（Copy-on-Write）とは</strong>

MAP_PRIVATE でマップしたメモリに書き込むと、カーネルはその時点でページのコピーを作成します

読み取りだけなら元のページを共有し、書き込みが発生した時点で初めてコピーを作るため、メモリを効率的に使えます

### 保護属性

| フラグ     | 説明         |
| ---------- | ------------ |
| PROT_NONE  | アクセス禁止 |
| PROT_READ  | 読み取り可能 |
| PROT_WRITE | 書き込み可能 |
| PROT_EXEC  | 実行可能     |

### munmap() による解放

`mmap()` で確保したメモリは `munmap()` で解放します

```c
munmap(mem, size);
```

---

## メモリ保護（mprotect）

### なぜメモリ保護が必要なのか

仮想メモリによって、各プロセスは独立したアドレス空間を持ちます

これにより、<strong>プロセス A はプロセス B のメモリを読み書きできません</strong>

しかし、プロセス内部でも保護が必要な場面があります

<strong>もしメモリ保護がなかったら？</strong>

例えば、プログラムのコード領域（テキスト領域）が書き込み可能だったとします

悪意のある入力（バッファオーバーフローなど）により、攻撃者がコード領域を書き換えることができてしまいます

書き換えられたコードが実行されると、任意のコードを実行される危険があります

また、データ領域が実行可能だったとします

攻撃者がデータ領域に悪意のあるコードを配置し、そこにジャンプさせることで、任意のコードを実行できてしまいます

<strong>メモリ保護による防御</strong>

Linux では、各メモリ領域に「読み取り」「書き込み」「実行」の権限を個別に設定できます

- テキスト領域：読み取りと実行のみ（書き込み禁止）
- データ領域：読み取りと書き込みのみ（実行禁止）
- スタック領域：読み取りと書き込みのみ（実行禁止、NX ビット）

これにより、たとえバッファオーバーフローが発生しても、攻撃の成功を困難にします

### mprotect() とは

`mprotect()` は、メモリ領域の保護属性を変更するシステムコールです

mprotect(2) の man ページには、こう書かれています

> mprotect() changes the access protections for the calling process's memory pages.

> mprotect() は呼び出しプロセスのメモリページのアクセス保護を変更します

### 使用例

```c
/* 読み取り専用に変更 */
mprotect(mem, page_size, PROT_READ);

/* 読み書き可能に戻す */
mprotect(mem, page_size, PROT_READ | PROT_WRITE);

/* アクセス禁止に変更 */
mprotect(mem, page_size, PROT_NONE);
```

### 保護違反と SIGSEGV

許可されていないアクセスを行うと、<strong>SIGSEGV</strong>（セグメンテーション違反）シグナルが発生します

シグナルとは、カーネルがプロセスに送る通知のことです

<strong>なぜシグナルで通知するのか？</strong>

メモリ保護違反は、CPU がそのアドレスにアクセスしようとした<strong>まさにその瞬間</strong>に検出されます

このような即座の通知を<strong>同期的なエラー通知</strong>と呼びます

カーネルは、エラーが発生したプロセスに対してシグナルを送り、「何か問題が起きた」ことを知らせます

<strong>もし即座に通知しなかったら？</strong>

エラーを後で通知した場合、プログラムはその間も誤った状態で動作を続けてしまいます

データが破損したり、さらに深刻な問題が発生する可能性があります

SIGSEGV による即座の停止は、被害の拡大を防ぐための設計です

SIGSEGV を受け取ったプロセスは、通常そのまま異常終了します

デバッグのために、コアダンプ（プロセスのメモリ内容を保存したファイル）を生成することもできます

### mprotect() の用途

- <strong>ガードページ</strong>：スタックオーバーフローを検出
- <strong>JIT コンパイラ</strong>：実行時に生成したコードを実行可能にする
- <strong>メモリデバッグ</strong>：特定領域へのアクセスを監視

JIT（Just-In-Time）コンパイラは、プログラムの実行中に機械語コードを生成します

生成したコードを実行するには、そのメモリ領域に実行権限（PROT_EXEC）を付与する必要があります

### 注意点

- `mprotect()` はページ単位で動作し、指定したアドレスはページ境界に揃っている必要がある
- 対象メモリ領域は `mmap()` または `mprotect()` で確立された単一のマッピングに含まれている必要がある

---

## メモリのロック（mlock）

### mlock() とは

`mlock()` は、メモリページを物理メモリにロックするシステムコールです

mlock(2) の man ページには、こう書かれています

> mlock() locks pages in the address range starting at addr, so that those pages are guaranteed to be resident in RAM.

> mlock() は addr から始まるアドレス範囲のページをロックし、それらのページが RAM に常駐することを保証します

### なぜメモリをロックするのか

通常、カーネルは物理メモリが不足すると、使用頻度の低いページをディスク上の<strong>スワップ領域</strong>に退避させます

この動作を<strong>スワップアウト</strong>と呼びます

`mlock()` でロックされたページは、スワップアウトの対象から除外されます

<strong>1. リアルタイムシステム</strong>

ページフォルトによる遅延を防ぎ、確定的な応答時間を保証します

<strong>2. セキュリティ</strong>

パスワードや暗号鍵がスワップ領域に書き出されるのを防ぎます

### 使用例

```c
/* メモリをロック */
mlock(mem, size);

/* ロックを解除 */
munlock(mem, size);
```

### 制限

- `RLIMIT_MEMLOCK` でロックできるメモリ量が制限されています
- 制限を超えるには root 権限または `CAP_IPC_LOCK` が必要です

```bash
ulimit -l  # 制限値を確認
```

### 注意点

- `mlock()` で設定したロックは `fork()` で作成された子プロセスに継承されない
- `execve()` の実行時にロックは自動的に解除される
- `mlock()` はページ単位で動作し、指定したアドレスは自動的にページ境界に切り下げられる

---

## /proc/self/smaps で詳細情報を取得

### /proc/self/smaps とは

`/proc/self/smaps` は、`/proc/self/maps` の拡張版で、各メモリ領域の詳細な統計情報を提供します

### 主要なフィールド

| フィールド    | 説明                                          |
| ------------- | --------------------------------------------- |
| Size          | マッピングの仮想サイズ                        |
| Rss           | 物理メモリ上にあるサイズ（Resident Set Size） |
| Pss           | 共有を按分したサイズ（Proportional Set Size） |
| Shared_Clean  | 共有、変更なし                                |
| Shared_Dirty  | 共有、変更あり                                |
| Private_Clean | プライベート、変更なし                        |
| Private_Dirty | プライベート、変更あり                        |
| Referenced    | 最近参照されたメモリのサイズ                  |
| Anonymous     | 無名マッピングのサイズ                        |
| Swap          | スワップに退避されたサイズ                    |

### RSS vs PSS

| 指標 | 説明                                       |
| ---- | ------------------------------------------ |
| RSS  | 共有ライブラリを全体としてカウント         |
| PSS  | 共有ライブラリをプロセス数で割ってカウント |

PSS はシステム全体のメモリ使用量をより正確に把握できます

---

## 用語集

| 用語                   | 英語                   | 説明                                               |
| ---------------------- | ---------------------- | -------------------------------------------------- |
| 仮想メモリ             | Virtual Memory         | プロセスごとに独立したアドレス空間を提供する仕組み |
| 仮想アドレス           | Virtual Address        | プログラムから見えるアドレス                       |
| 物理アドレス           | Physical Address       | 実際の RAM 上のアドレス                            |
| アドレス空間           | Address Space          | プロセスが使用できるアドレスの範囲                 |
| ページ                 | Page                   | メモリ管理の最小単位（通常 4KB）                   |
| ページテーブル         | Page Table             | 仮想と物理アドレスの対応表                         |
| ページフォルト         | Page Fault             | 未割り当てページへのアクセス時に発生する例外       |
| デマンドページング     | Demand Paging          | 必要時まで物理メモリ割り当てを遅延する仕組み       |
| mmap                   | Memory Map             | メモリ領域をアドレス空間にマップする               |
| 無名マッピング         | Anonymous Mapping      | ファイルに関連付けられないメモリマッピング         |
| ファイルマッピング     | File Mapping           | ファイルをメモリ上に展開するマッピング             |
| 共有マッピング         | Shared Mapping         | 複数プロセスで共有されるマッピング                 |
| プライベートマッピング | Private Mapping        | プロセス固有のマッピング（コピーオンライト）       |
| メモリ保護             | Memory Protection      | 読み取り、書き込み、実行の許可を制御する           |
| メモリロック           | Memory Lock            | ページを物理メモリに固定する                       |
| RSS                    | Resident Set Size      | 物理メモリ上にあるサイズ                           |
| PSS                    | Proportional Set Size  | 共有を按分したサイズ                               |
| MMU                    | Memory Management Unit | アドレス変換を行うハードウェア                     |
| スワップ               | Swap                   | 物理メモリ不足時にページをディスクに退避する仕組み |
| スワップアウト         | Swap Out               | ページをスワップ領域に退避すること                 |
| コピーオンライト       | Copy-on-Write          | 書き込み時にコピーを作成する最適化                 |

---

## 参考資料

このページの内容は、以下のソースに基づいています

<strong>システムコール</strong>

- [mmap(2) - Linux manual page](https://man7.org/linux/man-pages/man2/mmap.2.html)
  - メモリマッピング
- [munmap(2) - Linux manual page](https://man7.org/linux/man-pages/man2/munmap.2.html)
  - マッピングの解除
- [mprotect(2) - Linux manual page](https://man7.org/linux/man-pages/man2/mprotect.2.html)
  - メモリ保護属性の変更
- [mlock(2) - Linux manual page](https://man7.org/linux/man-pages/man2/mlock.2.html)
  - メモリのロック
- [msync(2) - Linux manual page](https://man7.org/linux/man-pages/man2/msync.2.html)
  - ファイルへの同期
- [getpagesize(2) - Linux manual page](https://man7.org/linux/man-pages/man2/getpagesize.2.html)
  - ページサイズの取得

<strong>疑似ファイルシステム</strong>

- [proc(5) - Linux manual page](https://man7.org/linux/man-pages/man5/proc.5.html)
  - /proc/[pid]/maps、/proc/[pid]/smaps

<strong>ライブラリ関数</strong>

- [sysconf(3) - Linux manual page](https://man7.org/linux/man-pages/man3/sysconf.3.html)
  - \_SC_PAGESIZE

<strong>カーネルドキュメント</strong>

- [The Linux Kernel documentation - Memory Management](https://www.kernel.org/doc/html/latest/admin-guide/mm/)
  - カーネルのメモリ管理

---

## 次のステップ

このトピックでは、仮想メモリの仕組みと、メモリマッピングを「観察」する方法を学びました

次の [04-process-management](./04-process-management.md) では、カーネルがプロセスを管理する責務について学びます

- カーネルはプロセスをどのように管理しているのか
- /proc/[pid]/status から読み取れる情報
- プロセスグループとセッション
- デーモンプロセスの作成

これらの疑問に答えます
