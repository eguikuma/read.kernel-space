<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# ファイルとは本当は何なのか

## はじめに

[01-kernel](../01-kernel.md) の「ファイルシステム」で、カーネルがファイルの読み書きを管理していると学びました

普段、私たちは「ファイル = データの塊」と考えています

```bash
ls -l myfile.txt
```

このコマンドでファイル名、サイズ、更新日時が表示されます

でも、ファイルを削除したはずなのにデータが残っていたり、同じファイルに複数の名前が付いていたりすることがあります

なぜそんなことが起きるのでしょうか？

実は、<strong>ファイル名とファイルの中身は別々に管理されています</strong>

このドキュメントでは、ファイルシステムの内部構造を「なぜそうなっているのか」という視点で説明します

---

## 目次

- [ファイルシステムの「なぜ」](#ファイルシステムのなぜ)
- [ファイルの正体：inode](#ファイルの正体inode)
- [ディレクトリエントリ：名前とinodeの橋渡し](#ディレクトリエントリ名前とinodeの橋渡し)
- [ブロック：実際のデータの保存場所](#ブロック実際のデータの保存場所)
- [VFS：なぜ抽象化が必要なのか](#vfsなぜ抽象化が必要なのか)
- [ファイルを開くとき何が起きるか](#ファイルを開くとき何が起きるか)
- [ハードリンクとシンボリックリンク](#ハードリンクとシンボリックリンク)
- [確認方法](#確認方法)
- [まとめ](#まとめ)
- [参考資料](#参考資料)

---

## ファイルシステムの「なぜ」

### なぜファイルという概念が生まれたのか

初期のコンピュータには「ファイル」という概念がありませんでした

プログラマは、ディスクのどのセクタにデータを書くかを直接指定していました

```
「セクタ 100〜150 にデータを書く」
「セクタ 200〜250 から読む」
```

これでは、どこに何を書いたかを覚えておく必要があり、間違えると他のデータを壊してしまいます

<strong>ファイルシステムの発明</strong>

1960 年代、UNIX の開発者たちは「名前でデータを管理する」という発想を持ちました

- データに名前を付けて保存する
- 名前を指定すれば、OS が場所を解決してくれる
- プログラマはセクタ番号を意識しなくて良い

これが「ファイル」の始まりです

### なぜ階層構造（ディレクトリ）が必要なのか

ファイルに名前を付けられるようになると、次の問題が発生しました

<strong>フラットな名前空間の限界</strong>

- `report.txt` という名前のファイルを 2 人が作りたい
- 何千ものファイルの中から目的のファイルを探すのが大変
- 関連するファイルをグループ化できない

<strong>解決策：ディレクトリ</strong>

ディレクトリ（フォルダ）を導入することで、名前空間を分割しました

```
/home/alice/report.txt
/home/bob/report.txt
```

同じ `report.txt` でも、ディレクトリが異なれば共存できます

---

## ファイルの正体：inode

### inodeとは

Linux のマニュアルには、こう書かれています

> Each file has an inode containing metadata about the file.

> 各ファイルは、ファイルに関するメタデータを含む inode を持ちます

<strong>inode（アイノード）</strong>は、ファイルの「本体」を表すデータ構造です

私たちが「ファイル」と呼んでいるものは、実は 2 つの部分から成り立っています

| 要素                 | 役割                   |
| -------------------- | ---------------------- |
| inode                | ファイルの本体（実体） |
| ディレクトリエントリ | ファイル名（ラベル）   |

### 日常の例え

図書館を想像してください

- <strong>本</strong>（inode）：実際の内容を持つ
- <strong>カード目録</strong>（ディレクトリエントリ）：本の場所を示すラベル

本には「本そのもの」と「カード目録の情報」があります

同じ本に対して、複数の目録カード（「著者名で探す」「タイトルで探す」）を作れます

カードを増やしても、本自体は 1 冊のままです

ファイルも同様に、1 つの inode（本体）に複数の名前（目録カード）を付けられます

### inodeが持つ情報

inode には、ファイルに関するメタデータが格納されています

| 情報                   | 説明                                   |
| ---------------------- | -------------------------------------- |
| ファイルタイプ         | 通常ファイル、ディレクトリ、リンクなど |
| パーミッション         | 読み取り、書き込み、実行の権限         |
| 所有者/グループ        | ファイルの所有者とグループ             |
| サイズ                 | ファイルのバイト数                     |
| タイムスタンプ         | atime、mtime、ctime                    |
| リンクカウント         | このinodeを参照している名前の数        |
| データブロックポインタ | 実際のデータがあるブロック番号         |

<strong>重要な点</strong>

inode には<strong>ファイル名が含まれていません</strong>

ファイル名は、inode とは別の場所（ディレクトリエントリ）で管理されています

### なぜファイル名はinodeに含まれないのか

この設計には明確な理由があります

<strong>理由 1：同じファイルに複数の名前を付けられる</strong>

もしファイル名が inode に入っていたら、1 つのファイルには 1 つの名前しか付けられません

名前を分離することで、1 つの inode（データ）に複数の名前を付けられます

これが後で説明する「ハードリンク」です

<strong>理由 2：名前の変更が高速</strong>

ファイルのリネーム（`mv oldname newname`）は、ディレクトリエントリを書き換えるだけで済みます

ファイルのデータ（inode やブロック）をコピーする必要がありません

---

## ディレクトリエントリ：名前とinodeの橋渡し

### ディレクトリエントリとは

<strong>ディレクトリエントリ</strong>は、ファイル名と inode 番号のペアです

```
ディレクトリエントリの構造

┌──────────────┬──────────────┐
│ ファイル名    │ inode 番号   │
├──────────────┼──────────────┤
│ myfile.txt   │ 12345        │
│ readme.md    │ 12346        │
│ data.csv     │ 12347        │
└──────────────┴──────────────┘
```

ファイル名を指定すると、対応する inode 番号がわかります

その inode 番号から、ファイルの本体（メタデータとデータ）にアクセスできます

### ディレクトリは「ファイル」である

UNIX の設計思想の 1 つに「すべてはファイル」があります

ディレクトリも例外ではありません

<strong>ディレクトリの正体</strong>

- ディレクトリも inode を持つ
- ディレクトリの「データ」は、配下のディレクトリエントリの一覧

つまり、ディレクトリは「ディレクトリエントリを格納した特殊なファイル」です

### `.` と `..` の意味

すべてのディレクトリには、2 つの特殊なエントリがあります

| エントリ | 指すもの               |
| -------- | ---------------------- |
| `.`      | 自分自身の inode       |
| `..`     | 親ディレクトリの inode |

```bash
ls -ai /home/user
```

出力例

```
 12345 .
 12300 ..
 12346 file.txt
```

`.` と `..` も通常のディレクトリエントリとして実装されています

### 名前解決の仕組み

`/home/user/file.txt` を開くとき、カーネルは以下の手順でパスを解決します

<strong>パス解決の流れ</strong>

1. ルートディレクトリ `/` の inode を取得（inode 番号 2 が慣例）
2. `/` のディレクトリエントリから `home` を探す → inode 番号を取得
3. `home` ディレクトリの inode からデータブロックを読む
4. そのディレクトリエントリから `user` を探す → inode 番号を取得
5. `user` ディレクトリの inode からデータブロックを読む
6. そのディレクトリエントリから `file.txt` を探す → inode 番号を取得
7. `file.txt` の inode にアクセス

<strong>ディレクトリキャッシュ（dentry cache）</strong>

この手順は、深い階層ほど遅くなります

カーネルは、一度解決したパスをキャッシュすることで高速化しています

---

## ブロック：実際のデータの保存場所

### ブロックとは

inode にはファイルのメタデータが入っていますが、実際のデータ（ファイルの中身）は<strong>ブロック</strong>に保存されています

<strong>ブロック</strong>は、ディスク上のデータ管理単位です

典型的なブロックサイズは 4KB で、これはメモリのページサイズと同じです

### inodeとブロックの関係

inode は、データが格納されているブロックの番号を持っています

```
inode 構造（簡略化）

┌─────────────────────────┐
│ ファイルタイプ、パーミッション  │
│ 所有者、サイズ、タイムスタンプ  │
├─────────────────────────┤
│ 直接ブロックポインタ（12個）   │
│ [100] [101] [102] ...        │
├─────────────────────────┤
│ 間接ブロックポインタ          │
│ [500]  → ブロック 500 に     │
│           追加のポインタが格納 │
└─────────────────────────┘
```

<strong>小さいファイルの場合</strong>

12 個の直接ブロックポインタで、最大 48KB（4KB × 12）のデータを指せます

<strong>大きいファイルの場合</strong>

間接ブロック、二重間接ブロック、三重間接ブロックを使って、より大きなファイルに対応します

| ポインタの種類 | 指せるブロック数 | 最大サイズ（4KB ブロック） |
| -------------- | ---------------- | -------------------------- |
| 直接           | 12               | 48KB                       |
| 間接           | 1024             | 4MB                        |
| 二重間接       | 1024 × 1024      | 4GB                        |
| 三重間接       | 1024^3           | 4TB                        |

### なぜブロック単位で管理するのか

<strong>理由 1：バイト単位管理の問題</strong>

もしバイト単位でディスクを管理すると、1TB のディスクには 1 兆個のエントリが必要になります

ブロック単位にすることで、管理するエントリ数を大幅に削減できます

<strong>理由 2：ディスクとの整合性</strong>

ディスクはセクタ（512B〜4KB）単位で読み書きします

ブロックサイズをセクタの倍数にすることで、効率的な I/O が可能になります

<strong>理由 3：ページサイズとの整合性</strong>

[page](./page.md) で学んだように、メモリはページ（4KB）単位で管理されます

ブロックサイズをページサイズと一致させることで、ディスクからメモリへの転送が効率的になります

---

## VFS：なぜ抽象化が必要なのか

### ファイルシステムの多様性

Linux は多くのファイルシステムをサポートしています

| 種類         | 例                 |
| ------------ | ------------------ |
| ローカル     | ext4、XFS、Btrfs   |
| ネットワーク | NFS、CIFS、SSHFS   |
| 疑似         | /proc、/sys        |
| メディア     | FAT、NTFS、ISO9660 |

それぞれのファイルシステムは、inode やブロックの管理方法が異なります

<strong>アプリケーションの視点での問題</strong>

もし各ファイルシステムに直接アクセスする必要があったら

```c
/*
 * これは非現実的な例
 */
if (is_ext4(path)) {
    ext4_open(path);
} else if (is_nfs(path)) {
    nfs_open(path);
} else if (is_proc(path)) {
    proc_open(path);
}
```

ファイルシステムごとに異なるコードを書く必要があり、新しいファイルシステムが追加されるたびにアプリケーションを修正しなければなりません

### VFS（仮想ファイルシステム）の役割

この問題を解決するのが<strong>VFS（Virtual File System）</strong>です

Linux カーネルのドキュメントには、こう書かれています

> The Virtual File System is a kernel software layer that handles all system calls related to a standard Unix file system.

> 仮想ファイルシステムは、標準的な UNIX ファイルシステムに関連するすべてのシステムコールを処理するカーネルソフトウェア層です

VFS は、アプリケーションと実際のファイルシステムの間に立つ<strong>抽象化層</strong>です

```
アプリケーション
    │
    │ open(), read(), write()
    ▼
┌─────────────────────────┐
│         VFS             │ ← 統一されたインターフェース
└─────────────────────────┘
    │       │       │
    ▼       ▼       ▼
  ext4    NFS    /proc     ← 各ファイルシステムの実装
```

### VFSの構造

VFS は、4 つの主要なオブジェクトで構成されています

| オブジェクト | 役割                                 |
| ------------ | ------------------------------------ |
| superblock   | ファイルシステム全体の情報           |
| inode        | ファイルのメタデータ（VFS 共通形式） |
| dentry       | ディレクトリエントリのキャッシュ     |
| file         | 開いているファイルの状態             |

<strong>operation 構造体</strong>

各オブジェクトには、操作を定義する関数ポインタのテーブルがあります

```
例：file_operations

read   → ext4_file_read()
write  → ext4_file_write()
open   → ext4_file_open()
```

ファイルシステムごとに、これらの関数を実装します

VFS は適切な関数を呼び出すだけで、具体的な処理は各ファイルシステムに任せます

---

## ファイルを開くとき何が起きるか

### open()の内部動作

`open("/home/user/file.txt", O_RDONLY)` を呼び出すと、カーネル内部で以下が起きます

<strong>ステップ 1：パスの解決</strong>

1. パスを `/`、`home`、`user`、`file.txt` に分解
2. 各コンポーネントを順に辿る（dentry cache を活用）
3. 最終的に `file.txt` の inode を取得

<strong>ステップ 2：権限チェック</strong>

1. inode のパーミッションを確認
2. 呼び出し元の uid/gid と比較
3. 要求された操作（読み取り、書き込み等）が許可されているか確認

<strong>ステップ 3：file 構造体の作成</strong>

1. カーネル内に file 構造体を作成
2. 現在のファイル位置（オフセット）を 0 に初期化
3. inode への参照を設定

<strong>ステップ 4：ファイルディスクリプタの割り当て</strong>

1. プロセスの fd テーブルから空きスロットを探す
2. file 構造体へのポインタを格納
3. fd 番号（整数）をアプリケーションに返す

### ファイルディスクリプタとの関係

前のシリーズで学んだファイルディスクリプタは、この仕組みの一部です

```
プロセス
┌────────────────────┐
│ fd テーブル         │
│ [0] → stdin        │
│ [1] → stdout       │
│ [2] → stderr       │
│ [3] → file 構造体 ─┼──┐
└────────────────────┘  │
                        ▼
        ┌─────────────────────────┐
        │ file 構造体              │
        │ ・現在位置（オフセット）  │
        │ ・オープンモード         │
        │ ・inode へのポインタ ────┼──┐
        └─────────────────────────┘  │
                                     ▼
                        ┌─────────────────────────┐
                        │ inode                   │
                        │ ・パーミッション         │
                        │ ・サイズ                │
                        │ ・ブロックポインタ       │
                        └─────────────────────────┘
```

<strong>なぜ 3 層構造なのか</strong>

| 層          | 理由                                           |
| ----------- | ---------------------------------------------- |
| fd テーブル | プロセスごとに独立したファイル番号を提供       |
| file 構造体 | 同じファイルでも別々の読み取り位置を保持できる |
| inode       | ファイルの実体は 1 つだけ存在すればよい        |

---

## ハードリンクとシンボリックリンク

### なぜリンクが必要なのか

同じファイルに複数の場所からアクセスしたいことがあります

- バックアップ：同じデータを 2 箇所で参照したい
- 互換性：古い名前と新しい名前の両方を使いたい
- ショートカット：深い階層のファイルに簡単にアクセスしたい

### ハードリンクの仕組み

<strong>ハードリンク</strong>は、同じ inode を指す別のディレクトリエントリです

```bash
# ハードリンクの作成
ln original.txt hardlink.txt
```

```
ディレクトリエントリ          inode
┌──────────────┬─────────┐
│ original.txt │ 12345   │──┐    ┌─────────────────┐
└──────────────┴─────────┘  ├───→│ inode 12345     │
┌──────────────┬─────────┐  │    │ リンクカウント: 2 │
│ hardlink.txt │ 12345   │──┘    │ データブロック...  │
└──────────────┴─────────┘       └─────────────────┘
```

<strong>リンクカウント</strong>

inode には、自分を参照しているディレクトリエントリの数（リンクカウント）が記録されています

ファイルを削除すると、リンクカウントが 1 減ります

リンクカウントが 0 になったとき、初めてデータブロックが解放されます

<strong>ハードリンクの制約</strong>

| 制約                       | 理由                                     |
| -------------------------- | ---------------------------------------- |
| 同じファイルシステム内のみ | inode 番号はファイルシステム内でのみ有効 |
| ディレクトリには作成不可   | ループを防ぐため（root でも禁止）        |

### シンボリックリンクの仕組み

<strong>シンボリックリンク</strong>（symlink）は、パスを格納した特殊なファイルです

```bash
# シンボリックリンクの作成
ln -s /original/path symlink
```

```
ディレクトリエントリ          inode
┌──────────────┬─────────┐    ┌─────────────────────┐
│ symlink      │ 99999   │───→│ inode 99999         │
└──────────────┴─────────┘    │ タイプ: symlink     │
                              │ データ: "/original/path" │
                              └─────────────────────┘
                                       │
                                       │（参照）
                                       ▼
                              ┌─────────────────────┐
                              │ /original/path      │
                              └─────────────────────┘
```

<strong>シンボリックリンクの特徴</strong>

- 独自の inode を持つ（参照先とは別）
- データとしてパス文字列を格納
- 参照先が存在しなくても作成できる（dangling symlink）
- ファイルシステムをまたいで作成可能

### 両者の違いと使い分け

| 観点             | ハードリンク               | シンボリックリンク         |
| ---------------- | -------------------------- | -------------------------- |
| inode            | 同じ inode を共有          | 独自の inode を持つ        |
| 参照先削除時     | 他のリンクからアクセス可能 | リンク切れになる           |
| ファイルシステム | 同一内のみ                 | またいで作成可能           |
| ディレクトリ     | 不可                       | 可能                       |
| ディスク使用量   | 増えない                   | わずかに増える             |
| 主な用途         | バックアップ、重複排除     | ショートカット、互換性維持 |

---

## 確認方法

### inodeの確認

```bash
# inode 番号を表示
ls -i filename
```

出力例

```
12345 filename
```

```bash
# 詳細な inode 情報
stat filename
```

出力例

```
  File: filename
  Size: 1024            Blocks: 8          IO Block: 4096   regular file
Device: 801h/2049d      Inode: 12345       Links: 1
Access: (0644/-rw-r--r--)  Uid: ( 1000/   user)   Gid: ( 1000/   user)
Access: 2024-01-15 10:00:00.000000000 +0900
Modify: 2024-01-15 09:00:00.000000000 +0900
Change: 2024-01-15 09:00:00.000000000 +0900
```

### ブロックの確認

```bash
# 使用ブロック数
stat filename | grep Blocks
```

```bash
# ブロックの配置（断片化の確認）
filefrag -v filename
```

### リンクの確認

```bash
# リンクカウントを確認
stat filename | grep Links
```

```bash
# 同じ inode を持つファイルを検索（ハードリンクの検出）
find /path -inum 12345
```

```bash
# シンボリックリンクの参照先
readlink symlink
```

```bash
# シンボリックリンクの詳細
ls -l symlink
```

出力例

```
lrwxrwxrwx 1 user user 14 Jan 15 10:00 symlink -> /original/path
```

---

## まとめ

<strong>ファイルの本質</strong>

| ポイント                   | 説明                                         |
| -------------------------- | -------------------------------------------- |
| ファイル名は「ラベル」     | 本体（inode）を指す名前に過ぎない            |
| inode がファイルの正体     | メタデータとデータブロックへのポインタを持つ |
| ディレクトリは名前の管理者 | ディレクトリエントリで名前と inode を紐づけ  |
| VFS が抽象化を提供         | どのファイルシステムも同じ操作で扱える       |

<strong>覚えておくこと</strong>

| ポイント                  | 説明                                  |
| ------------------------- | ------------------------------------- |
| ハードリンク              | 同じ inode を共有する別名             |
| シンボリックリンク        | パスを格納した別ファイル              |
| open() の流れ             | パス解決 → 権限チェック → fd 割り当て |
| リンクカウントが 0 で解放 | ファイル削除は「名前を消す」こと      |

---

## 参考資料

<strong>Linux マニュアル</strong>

- [inode(7) - Linux manual page](https://man7.org/linux/man-pages/man7/inode.7.html)
  - inode の詳細な説明
- [stat(2) - Linux manual page](https://man7.org/linux/man-pages/man2/stat.2.html)
  - ファイルのメタデータ取得
- [open(2) - Linux manual page](https://man7.org/linux/man-pages/man2/open.2.html)
  - ファイルを開くシステムコール
- [link(2) - Linux manual page](https://man7.org/linux/man-pages/man2/link.2.html)
  - ハードリンクの作成
- [symlink(2) - Linux manual page](https://man7.org/linux/man-pages/man2/symlink.2.html)
  - シンボリックリンクの作成

<strong>Linux カーネルドキュメント</strong>

- [Overview of the Linux Virtual File System - kernel.org](https://www.kernel.org/doc/html/latest/filesystems/vfs.html)
  - VFS の公式ドキュメント

<strong>本編との関連</strong>

- [01-kernel](../01-kernel.md)
  - カーネルの概要、/proc と /sys
- [sys](./sys.md)
  - 疑似ファイルシステム /proc と /sys の比較
- [page](./page.md)
  - ページサイズとブロックサイズの関係
