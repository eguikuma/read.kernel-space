<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# 04-process-management：カーネルのプロセス管理

## はじめに

[03-virtual-memory](./03-virtual-memory.md) では、カーネルがプロセスごとに独立したメモリ空間を提供する仕組みを学びました

- 仮想メモリと物理メモリの違い
- ページングによるアドレス変換
- /proc/self/maps でメモリマップを観察する方法
- mmap() によるメモリマッピング

しかし、メモリは「プロセス」が使うものです

では、カーネルは「プロセス」そのものをどのように管理しているのでしょうか？

前のシリーズでは、プロセスを<strong>使う側</strong>の視点で学びました

- fork() でプロセスを作る
- exec() でプログラムを実行する
- シグナルでプロセスに通知する
- wait() で子プロセスの終了を待つ

このページでは、その<strong>裏側</strong>を学びます

カーネルは各プロセスについて何を記録しているのか、プロセスグループやセッションとは何か、デーモンプロセスはなぜ特別な手順で作られるのか

これらの疑問に答えます

### 日常の例え

カーネルのプロセス管理を「ホテルの宿泊管理システム」に例えてみましょう

<strong>各ゲスト（プロセス）</strong>には、固有の部屋番号（PID）が割り当てられます

チェックアウト後、その部屋番号は次のゲストに再利用されることがあります

<strong>フロントデスク（カーネル）</strong>は、各ゲストについて以下の情報を管理しています

- 身分証明（UID、GID）
- 所属するツアーグループ（プロセスグループ）
- 参加しているイベント（セッション）
- 現在の状態（就寝中、会議室にいる、チェックアウト済み）
- 家族関係（親プロセス、子プロセス）

<strong>チェックイン（fork/clone）</strong>では、既存のゲストの情報をコピーして新しいゲストを登録します

<strong>チェックアウト（exit）</strong>では、部屋は片付けられますが、フロントデスクはグループリーダー（親プロセス）が確認するまでチェックアウト記録だけを保持します

<strong>VIP ゲスト（デーモン）</strong>は、ツアーグループから離脱して独立して行動します

### このページで学ぶこと

このページでは、以下の概念を学びます

- <strong>カーネルがプロセスについて管理する情報</strong>
  - プロセス記述子の概念モデル
- <strong>プロセスの状態</strong>
  - R、S、D、T、Z などの状態と観察方法
- <strong>/proc/[pid]/ でプロセスを観察する</strong>
  - status、stat、comm などの詳細
- <strong>プロセスの資格情報</strong>
  - UID、GID、ケーパビリティ
- <strong>プロセスグループとセッション</strong>
  - pgid、sid、シェルのジョブ制御との関係
- <strong>制御端末</strong>
  - 端末シグナルとプロセスの関係
- <strong>デーモンプロセス</strong>
  - 作成手順と systemd との関係
- <strong>プロセスの作成（カーネル視点）</strong>
  - fork/clone でカーネルが行う処理
- <strong>プロセスの終了とゾンビ</strong>
  - exit 時の処理とゾンビの存在理由

---

## 目次

1. [カーネルがプロセスについて管理する情報](#カーネルがプロセスについて管理する情報)
2. [プロセスの状態](#プロセスの状態)
3. [/proc/[pid]/ でプロセスを観察する](#procpid-でプロセスを観察する)
4. [プロセスの資格情報](#プロセスの資格情報)
5. [プロセスグループとセッション](#プロセスグループとセッション)
6. [制御端末](#制御端末)
7. [デーモンプロセス](#デーモンプロセス)
8. [プロセスの作成（カーネル視点）](#プロセスの作成カーネル視点)
9. [プロセスの終了とゾンビ](#プロセスの終了とゾンビ)
10. [用語集](#用語集)
11. [参考資料](#参考資料)

---

## カーネルがプロセスについて管理する情報

### プロセス記述子とは

カーネルは、各プロセスについて多くの情報を管理しています

この情報を格納するデータ構造を<strong>プロセス記述子</strong>（process descriptor）と呼びます

Linux の公式マニュアルには、こう書かれています

> The /proc/[pid] subdirectories contain pseudo-files that can be used to read process information.

> /proc/[pid] サブディレクトリには、プロセス情報を読み取るために使用できる疑似ファイルが含まれています

カーネルソースでは `task_struct` という構造体で実装されていますが、このリポジトリではソースコードは読みません

代わりに、「カーネルは何を管理しているか」を概念モデルとして理解します

### 管理される情報のカテゴリ

カーネルがプロセスごとに管理する主な情報は以下のとおりです

| カテゴリ         | 管理される情報                     |
| ---------------- | ---------------------------------- |
| 識別情報         | PID、TGID、親プロセスの PID        |
| 資格情報         | UID、GID、ケーパビリティ           |
| 状態             | 実行中、休止中、ゾンビなど         |
| メモリ           | メモリマップへのポインタ           |
| ファイル         | 開いているファイルディスクリプタ   |
| シグナル         | 保留中のシグナル、シグナルハンドラ |
| スケジューリング | 優先度、CPU アフィニティ           |
| グループ         | プロセスグループ ID、セッション ID |
| 端末             | 制御端末                           |

### /proc/self/status で確認する

現在のプロセスの情報は `/proc/self/status` で確認できます

```bash
cat /proc/self/status
```

出力には、上記のカテゴリに対応する情報が含まれています

```
Name:   cat
State:  R (running)
Tgid:   12345
Pid:    12345
PPid:   12344
Uid:    1000    1000    1000    1000
Gid:    1000    1000    1000    1000
Groups: 1000 4 24 27
VmSize:     2048 kB
Threads:        1
```

---

## プロセスの状態

### 状態とは何か

プロセスは常にいずれかの<strong>状態</strong>（state）にあります

カーネルはこの状態を追跡し、適切なタイミングで CPU を割り当てます

### 主要な状態コード

`ps` コマンドや `/proc/[pid]/stat` で確認できる状態コードは以下のとおりです

| コード | 名前                        | 説明                                                         |
| ------ | --------------------------- | ------------------------------------------------------------ |
| R      | Running                     | 実行中、または実行可能（CPU 待ち）                           |
| S      | Sleeping（Interruptible）   | イベント待ちで休止中、シグナルで起こせる                     |
| D      | Sleeping（Uninterruptible） | I/O 待ちで休止中、シグナルで起こせない                       |
| T      | Stopped                     | シグナル（SIGSTOP、SIGTSTP）で停止中                         |
| t      | Tracing stop                | デバッガによるトレース中                                     |
| Z      | Zombie                      | 終了済み、親が wait() していない                             |
| I      | Idle                        | カーネルスレッドがアイドル状態のとき                         |
| X      | Dead                        | 終了済み、即座に削除されるため ps で観察される機会はほぼない |

### 状態の観察方法

<strong>ps コマンドで確認</strong>

```bash
ps aux | head -10
```

STAT 列に状態コードが表示されます

<strong>/proc/[pid]/stat で確認</strong>

```bash
cat /proc/self/stat
```

3 番目のフィールドが状態コードです

<strong>/proc/[pid]/status で確認</strong>

```bash
cat /proc/self/status | grep State
```

人間が読みやすい形式で表示されます

### D 状態（Uninterruptible Sleep）の意味

D 状態は「シグナルで中断できない休止状態」です

主にディスク I/O やネットワークファイルシステム（NFS など）の I/O 完了を待っているときに発生します

<strong>なぜシグナルで中断できないのか</strong>

ディスク I/O の途中で中断すると、データの整合性が失われる可能性があるためです

例えば、ファイルシステムのメタデータを更新している最中に中断されると、ファイルシステムが破損する可能性があります

<strong>SIGKILL でも殺せない理由</strong>

D 状態のプロセスは、<strong>SIGKILL（シグナル番号 9）でも強制終了できません</strong>

なぜでしょうか？

カーネルがシグナルを処理するのは、プロセスがユーザーモードに戻るタイミングです

しかし、D 状態のプロセスはカーネルモード内で I/O 完了を待っています

I/O が完了してカーネルの処理が終わるまで、シグナル処理のタイミングが来ないのです

これは「殺せないバグ」ではなく、意図的な設計です

D 状態の詳しい実装については [appendices/process-state.md](./appendices/process-state.md) で学べます

<strong>D 状態への対処法</strong>

D 状態のプロセスが長時間続く場合、プロセス自体ではなく、その原因を調査する必要があります

- ディスクに障害がないか確認する（`dmesg` でエラーメッセージを確認）
- NFS サーバーが応答しているか確認する
- ストレージの負荷が高すぎないか確認する

D 状態のプロセスはロードアベレージの計算に含まれます

詳しくは [appendices/load-average.md](./appendices/load-average.md) で学べます

### Z 状態（ゾンビ）の意味

Z 状態は「終了したが、親がまだ wait() していない状態」です

なぜこの状態が必要なのでしょうか？

親プロセスが子の終了ステータスを取得できるように、カーネルは終了情報を保持しています

ゾンビプロセスはリソースをほとんど消費しませんが、PID を占有し続けます

親が wait() を呼び出すと、ゾンビは完全に削除されます

---

## /proc/[pid]/ でプロセスを観察する

### /proc/[pid]/ とは

`/proc/[pid]/` は、特定のプロセスの情報を公開する疑似ディレクトリです

[pid] の部分にプロセス ID を指定します

`/proc/self/` は、読み取りを行ったプロセス自身を指す特別なリンクです

### 主要なファイル

| ファイル            | 内容                                         |
| ------------------- | -------------------------------------------- |
| /proc/[pid]/status  | 人間が読みやすい形式のステータス情報         |
| /proc/[pid]/stat    | 機械処理向けのステータス情報                 |
| /proc/[pid]/statm   | メモリ統計                                   |
| /proc/[pid]/comm    | コマンド名（最大 16 文字）                   |
| /proc/[pid]/cmdline | 完全なコマンドライン                         |
| /proc/[pid]/cwd     | 現在の作業ディレクトリ（シンボリックリンク） |
| /proc/[pid]/exe     | 実行ファイル（シンボリックリンク）           |
| /proc/[pid]/fd/     | 開いているファイルディスクリプタ             |
| /proc/[pid]/task/   | このプロセス内のスレッド                     |

### /proc/[pid]/status の詳細

`/proc/[pid]/status` は最も情報量が多いファイルです

主要なフィールドを確認しましょう

| フィールド | 説明                                             |
| ---------- | ------------------------------------------------ |
| Name       | プロセス名                                       |
| State      | 現在の状態                                       |
| Tgid       | スレッドグループ ID（= メインスレッドの PID）    |
| Pid        | スレッド ID（シングルスレッドなら = PID）        |
| PPid       | 親プロセスの PID                                 |
| Uid        | 実 UID、実効 UID、保存 UID、ファイルシステム UID |
| Gid        | 実 GID、実効 GID、保存 GID、ファイルシステム GID |
| Groups     | 補助グループのリスト                             |
| VmSize     | 仮想メモリサイズ                                 |
| VmRSS      | 物理メモリ使用量（RSS）                          |
| Threads    | スレッド数                                       |

### /proc/[pid]/stat の詳細

`/proc/[pid]/stat` は `ps` などのツールが使用する形式です

```bash
cat /proc/self/stat
```

スペース区切りで多くのフィールドが並んでいます

主要なフィールドの位置は以下のとおりです

| 位置 | フィールド | 説明                |
| ---- | ---------- | ------------------- |
| 1    | pid        | プロセス ID         |
| 2    | comm       | コマンド名          |
| 3    | state      | 状態コード          |
| 4    | ppid       | 親プロセス ID       |
| 5    | pgrp       | プロセスグループ ID |
| 6    | session    | セッション ID       |
| 7    | tty_nr     | 制御端末            |

### /proc/[pid]/fd/ でファイルディスクリプタを確認

開いているファイルディスクリプタは `/proc/[pid]/fd/` で確認できます

```bash
ls -l /proc/self/fd/
```

各エントリは、ファイルディスクリプタ番号から実際のファイルへのシンボリックリンクです

---

## プロセスの資格情報

### 資格情報とは

<strong>資格情報</strong>（credentials）は、プロセスの「身分証明」です

カーネルはこの情報を使って、プロセスが何を許可されているかを判断します

プロセスは様々なユーザー ID とグループ ID を持ち、カーネルはこれらを使って共有リソース（メッセージキュー、共有メモリ、セマフォ、ファイルなど）へのアクセス許可を判断します

### UID の種類

プロセスには複数の UID があります

| 種類                  | 説明                                                                       |
| --------------------- | -------------------------------------------------------------------------- |
| 実 UID（Real）        | プロセスを起動したユーザーの ID                                            |
| 実効 UID（Effective） | 権限チェックに使用される ID                                                |
| 保存 UID（Saved）     | 一時的に権限を下げるための退避先                                           |
| ファイルシステム UID  | ファイルアクセス時に使用される ID（Linux 固有、通常は実効 UID と自動同期） |

<strong>ファイルシステム UID が存在する理由</strong>

NFS サーバーのように、クライアントに代わってファイルにアクセスするプログラムでは、実効 UID を変更せずにファイルアクセス権限だけを切り替えたい場合があります

ファイルシステム UID はこのような用途のために用意されています

通常のプログラムでは意識する必要はありません

<strong>なぜ複数の UID があるのか</strong>

setuid プログラム（`passwd` など）は、実行時に実効 UID を変更して特権操作を行います

保存 UID があることで、特権を一時的に下げてから元に戻すことができます

### GID の種類

GID も UID と同様に、実、実効、保存、ファイルシステムの 4 種類があります

### 補助グループ

プロセスは複数のグループに属することができます

これを<strong>補助グループ</strong>（supplementary groups）と呼びます

```bash
cat /proc/self/status | grep Groups
```

ファイルアクセス時、カーネルは実効 GID と補助グループすべてをチェックします

### ケーパビリティ

従来の UNIX では、root（UID 0）は「すべてができる」状態でした

<strong>ケーパビリティ</strong>（capabilities）は、この「全か無か」を細分化した仕組みです

| ケーパビリティ       | 許可される操作                 |
| -------------------- | ------------------------------ |
| CAP_NET_BIND_SERVICE | 1024 番未満のポートにバインド  |
| CAP_SYS_ADMIN        | 多くの管理操作                 |
| CAP_CHOWN            | ファイルの所有者を変更         |
| CAP_KILL             | 任意のプロセスにシグナルを送信 |

```bash
cat /proc/self/status | grep Cap
```

出力される値は 16 進数でエンコードされたビットマスク（複数の設定を 1 つの数値で表す形式）です

---

## プロセスグループとセッション

### なぜプロセスグループとセッションが必要なのか

シェルで以下のコマンドを実行した場合を考えてみましょう

```bash
ls | grep foo | wc -l
```

このコマンドは 3 つのプロセス（`ls`、`grep`、`wc`）を起動します

ここで Ctrl+C を押したとき、3 つのプロセスすべてが終了してほしいはずです

しかし、シグナルは通常、1 つのプロセスにしか送れません

<strong>プロセスグループ</strong>は、この問題を解決します

関連するプロセスをグループ化し、グループ全体に一括でシグナルを送れるようにします

### シェルのジョブ制御との関係

シェルの<strong>ジョブ制御</strong>機能は、プロセスグループを活用しています

| 操作                   | キー操作 | 動作                           | プロセスグループとの関係                   |
| ---------------------- | -------- | ------------------------------ | ------------------------------------------ |
| 中断                   | Ctrl+C   | SIGINT を送信                  | フォアグラウンドプロセスグループ全体に送信 |
| 一時停止               | Ctrl+Z   | SIGTSTP を送信                 | フォアグラウンドプロセスグループ全体を停止 |
| バックグラウンド実行   | `&`      | ジョブをバックグラウンドで実行 | 別のプロセスグループとして管理             |
| フォアグラウンドに戻す | `fg`     | ジョブをフォアグラウンドに戻す | プロセスグループをフォアグラウンドに設定   |

このように、プロセスグループはシェルがユーザーの操作を複数のプロセスに伝えるための仕組みです

### プロセスグループとは

<strong>プロセスグループ</strong>は、関連するプロセスの集合です

Linux の公式マニュアルには、こう書かれています

> A process group is a collection of one or more processes sharing the same process group identifier (PGID).

> プロセスグループは、同じプロセスグループ識別子（PGID）を共有する 1 つ以上のプロセスの集合です

シェルでパイプラインを実行すると、1 つのプロセスグループが作られます

```bash
ls | grep foo | wc -l
```

この例では、`ls`、`grep`、`wc` が同じプロセスグループに属します

### セッションとは

<strong>セッション</strong>は、プロセスグループの集合です

ログインセッションやターミナルセッションに対応します

| 概念               | 説明                                            |
| ------------------ | ----------------------------------------------- |
| セッション         | プロセスグループの集合                          |
| セッションリーダー | setsid() を呼び出してセッションを作ったプロセス |
| 制御端末           | セッションに関連付けられた端末（最大 1 つ）     |

setsid() は「プロセスグループリーダーではないプロセス」のみが呼び出せます

プロセスグループリーダーが setsid() を呼べない理由は、セッションとプロセスグループの階層構造を壊さないためです

もしリーダーが新しいセッションに移動すると、同じプロセスグループ内の他のプロセスが元のセッションに取り残され、「1 つのプロセスグループが複数のセッションにまたがる」という矛盾した状態になってしまいます

### 階層構造

セッション、プロセスグループ、プロセスの関係は階層的です

```
セッション（sid=1000）
├── フォアグラウンドプロセスグループ（pgid=1001）
│   ├── シェル（pid=1001）
│   └── ls（pid=1002）
└── バックグラウンドプロセスグループ（pgid=1003）
    └── sleep 100 &（pid=1003）
```

### 観察方法

```bash
ps -o pid,ppid,pgid,sid,tty,comm
```

| 列   | 説明                |
| ---- | ------------------- |
| PID  | プロセス ID         |
| PPID | 親プロセス ID       |
| PGID | プロセスグループ ID |
| SID  | セッション ID       |
| TTY  | 制御端末            |
| COMM | コマンド名          |

### シグナルとプロセスグループ

プロセスグループの重要な用途は、シグナルの一括送信です

```bash
kill -SIGNAL -PGID
```

マイナス記号を付けた PGID を指定すると、グループ全体にシグナルが送られます

シェルの Ctrl+C もこの仕組みを使っています

---

## 制御端末

### 制御端末とは

<strong>制御端末</strong>（controlling terminal）は、セッションに関連付けられた端末です

ターミナルから起動したプロセスは、通常そのターミナルを制御端末として持ちます

### 制御端末の役割

制御端末は、端末からのシグナルをプロセスに伝えます

| キー入力 | 送信されるシグナル | 送信先                           |
| -------- | ------------------ | -------------------------------- |
| Ctrl+C   | SIGINT             | フォアグラウンドプロセスグループ |
| Ctrl+Z   | SIGTSTP            | フォアグラウンドプロセスグループ |
| Ctrl+\   | SIGQUIT            | フォアグラウンドプロセスグループ |

### 制御端末の確認

現在の制御端末を確認するには `tty` コマンドを使います

```bash
tty
```

`ps` コマンドの TTY 列でも確認できます

```bash
ps -o pid,tty,comm
```

`?` は制御端末がないことを示します

### 制御端末を持たないプロセス

制御端末を持たないプロセスは、端末シグナル（Ctrl+C など）の影響を受けません

デーモンプロセスは、この特性を利用して端末から独立します

---

## デーモンプロセス

### デーモンとは

<strong>デーモン</strong>（daemon）は、端末から切り離されて動作するバックグラウンドプロセスです

Web サーバー（nginx、Apache）やデータベース（MySQL、PostgreSQL）などがデーモンとして動作します

Linux の公式マニュアルには、こう書かれています

> A daemon is a service process that runs in the background and supervises the system or provides functionality to other processes.

> デーモンは、バックグラウンドで動作し、システムを監視したり他のプロセスに機能を提供するサービスプロセスです

### なぜ特別な作成手順が必要か

デーモンには以下の特性が必要です

- 端末シグナル（Ctrl+C など）で終了しない
- 端末セッションの終了に巻き込まれない
- 親プロセスが終了しても動作を続ける

これらを実現するために、デーモンは特別な手順で作成されます

### 従来のデーモン作成手順

伝統的なデーモン作成手順は以下のとおりです

<strong>1. fork() して親を終了</strong>

シェルから切り離されます

<strong>2. setsid() で新しいセッションを作成</strong>

制御端末から切り離されます

<strong>3. 再度 fork() して親を終了</strong>

セッションリーダーでなくなり、制御端末を取得できなくなります

<strong>なぜ 2 回 fork するのか？</strong>

この手順を理解するには、歴史的な背景を知る必要があります

<strong>歴史的経緯：System V の制御端末取得ルール</strong>

Unix System V では、セッションリーダーが端末デバイスを open() すると、その端末が自動的に制御端末として設定されました

これは当時の設計としては合理的でしたが、デーモンにとっては問題です

デーモンがログファイルを書き込むつもりで端末デバイスを open() してしまうと、意図せず制御端末を取得してしまう可能性があります

Linux では `O_NOCTTY` フラグで制御端末の取得を防げますが、古い System V 互換のコードでは 2 回 fork する方法が使われました

<strong>2 回 fork の効果</strong>

1. 1 回目の fork() → setsid() で、新しいセッションのリーダーになる
2. 2 回目の fork() で親（セッションリーダー）を終了させる
3. 子プロセスはセッションリーダーではなくなる
4. セッションリーダーでないプロセスは、端末を open() しても制御端末を取得できない

これにより、デーモンが将来にわたって制御端末を取得できない状態を保証します

現代の Linux では `O_NOCTTY` を使えば 2 回 fork は必須ではありませんが、移植性のために今でも使われることがあります

<strong>4. 作業ディレクトリを / に変更</strong>

マウントポイントを占有しないようにします

<strong>5. ファイルディスクリプタ 0、1、2 を閉じるか /dev/null にリダイレクト</strong>

端末への入出力を無効化します

<strong>6. umask をリセット</strong>

ファイル作成時のパーミッションを制御します

### 一般的なアプローチ：systemd

多くの Linux では、systemd がデーモンのライフサイクルを管理します

サービスは自分で「デーモン化」する必要がありません

systemd がプロセスを適切に管理します

```ini
[Service]
Type=simple
ExecStart=/usr/bin/myservice
```

### デーモンの観察

```bash
ps aux | grep sshd
```

デーモンの特徴を確認できます

- PPID が 1（または systemd）
- TTY 列が `?`（制御端末なし）

```bash
cat /proc/$(pgrep -o sshd)/status | grep -E '^(PPid|State)'
```

---

## プロセスの作成（カーネル視点）

### fork() のカーネル側処理

ユーザー空間で `fork()` を呼び出したとき、カーネルは以下の処理を行います

<strong>1. 新しいプロセス記述子を割り当て</strong>

カーネルのメモリ領域に新しいプロセスの情報を格納する領域を確保します

<strong>2. 親のプロセス記述子をコピー</strong>

大部分の情報は親からコピーされます

<strong>3. 新しい PID を割り当て</strong>

システム内で一意の PID を割り当てます

<strong>4. メモリマッピングを設定</strong>

コピーオンライト方式で親のメモリマップを共有します（03-virtual-memory で学習済み）

<strong>5. ファイルディスクリプタテーブルをコピー</strong>

開いているファイルへの参照をコピーします

<strong>6. シグナルハンドラをコピー</strong>

シグナルの処理設定を引き継ぎます

<strong>7. 親プロセスへのポインタを設定</strong>

親子関係を記録します

<strong>8. スケジューラの実行可能キューに追加</strong>

CPU を割り当てられる状態になります

### fork() と clone()

Linux では、`fork()` は内部的に `clone()` システムコールを使用しています

| 特徴         | fork()                         | clone()            |
| ------------ | ------------------------------ | ------------------ |
| リソース共有 | 最小限                         | フラグで細かく制御 |
| メモリ       | コピーオンライト               | 共有も可能         |
| ファイル     | ディスクリプタテーブルをコピー | 共有も可能         |
| 用途         | 新しいプロセス                 | スレッド、コンテナ |

### clone() の主要なフラグ

| フラグ       | 効果                                             |
| ------------ | ------------------------------------------------ |
| CLONE_VM     | メモリ空間を共有                                 |
| CLONE_FILES  | ファイルディスクリプタテーブルを共有             |
| CLONE_THREAD | 同じスレッドグループに属する                     |
| CLONE_NEWPID | 新しい PID 名前空間を作成（06-namespace で詳述） |

### スレッドとプロセスの違い

カーネルの視点では、スレッドもプロセスも「タスク」として管理されます

違いは、どれだけリソースを共有するかです

<strong>プロセス</strong>

- 独立したメモリ空間
- 独立したファイルディスクリプタテーブル
- 独自の PID

<strong>スレッド</strong>

- メモリ空間を共有（CLONE_VM）
- ファイルディスクリプタテーブルを共有（CLONE_FILES）
- 同じ TGID（スレッドグループ ID）を共有
- 各スレッドは固有の TID（スレッド ID）を持つ

### スレッドの観察

```bash
cat /proc/[pid]/status | grep Threads
```

スレッド数を確認できます

```bash
ls /proc/[pid]/task/
```

各スレッドのディレクトリが表示されます

---

## プロセスの終了とゾンビ

### exit() のカーネル側処理

プロセスが `exit()` を呼び出したとき、カーネルは以下の処理を行います

<strong>1. すべてのファイルディスクリプタを閉じる</strong>

開いているファイル、ソケット、パイプなどを閉じます

<strong>2. 親プロセスに SIGCHLD を送信</strong>

子プロセスの状態変化を通知します

<strong>3. 子プロセスを init に引き渡し</strong>

残っている子プロセスの親を init（PID 1）に変更します

<strong>4. ほとんどのリソースを解放</strong>

メモリ、シグナルハンドラなどを解放します

<strong>5. 終了ステータスを保持</strong>

プロセス記述子に最小限の情報（終了ステータス）を残します

<strong>6. 状態を Z（ゾンビ）に変更</strong>

親が wait() を呼ぶまでこの状態で待機します

### ゾンビはなぜ存在するのか

ゾンビプロセスは、親プロセスが子の終了ステータスを取得できるように存在します

```c
int status;
pid_t child_pid = wait(&status);
/* status に子の終了ステータスが格納される */
```

親が wait() を呼ばないと、終了ステータスを取得する手段がなくなります

そのため、カーネルは親が wait() を呼ぶまで終了情報を保持します

<strong>もしゾンビがなかったら？</strong>

ゾンビプロセスがなく、子が終了した瞬間に完全に消滅してしまうとどうなるでしょうか？

親プロセスは、子プロセスが「正常に終了したのか」「エラーで終了したのか」「シグナルで殺されたのか」を知る手段がなくなります

例えば、シェルスクリプトで

```bash
some_command
if [ $? -eq 0 ]; then
    echo "成功"
else
    echo "失敗"
fi
```

`$?` は直前のコマンドの終了ステータスです

ゾンビがなければ、この情報を取得できません

<strong>親が wait() を呼ばない場合の具体例</strong>

以下のコードは、ゾンビを発生させる例です

```c
pid_t pid = fork();
if (pid == 0) {
    /* 子プロセス：すぐに終了 */
    exit(0);
}
/* 親プロセス：wait() を呼ばずに長時間スリープ */
sleep(60);  /* この間、子はゾンビとして残る */
```

親が wait() を呼ばない限り、子プロセスの終了情報はカーネル内に残り続けます

### ゾンビの問題

ゾンビ自体はリソースをほとんど消費しません（プロセス記述子の最小限の情報のみ）

しかし、PID を占有し続けます

Linux では `/proc/sys/kernel/pid_max` で設定された数（デフォルトで 32768 または 4194304）までしか PID を割り当てられません

大量のゾンビが発生すると、新しいプロセスを作成できなくなる可能性があります

### 孤児プロセスと init

親プロセスが先に終了すると、子プロセスは<strong>孤児プロセス</strong>（orphan process）になります

孤児プロセスは、init（PID 1）に引き取られます

init は定期的に wait() を呼び出すため、孤児が終了するとゾンビにならずに回収されます

### subreaper

現代の Linux では、init 以外のプロセスも孤児を引き取ることができます

```c
prctl(PR_SET_CHILD_SUBREAPER, 1);
```

これを設定したプロセスは、その配下で発生した孤児プロセスを引き取る役割を担います

通常、孤児プロセスは init（PID 1）に引き取られますが、subreaper を設定すると、その配下の孤児は subreaper に引き取られます

systemd やコンテナランタイムがこの機能を使用しています

### ゾンビの観察

```bash
# ゾンビを作成する例（別のターミナルで実行）
bash -c 'sleep 1 & exec sleep 60'

# 別のターミナルでゾンビを確認（約1秒後）
ps aux | grep defunct
```

`bash -c` で起動したシェルが `exec sleep 60` で置き換わり、バックグラウンドの `sleep 1` の親になります

`sleep 1` が終了しても、`sleep 60` は wait() を呼ばないため、ゾンビが発生します

```bash
# subreaper の設定を確認
cat /proc/[pid]/status | grep Subreaper
```

---

## 用語集

| 用語                             | 英語                     | 説明                                              |
| -------------------------------- | ------------------------ | ------------------------------------------------- |
| プロセス記述子                   | Process Descriptor       | カーネルがプロセスごとに管理するデータ構造        |
| スレッドグループ                 | Thread Group             | 同じプロセスに属するスレッドの集合（TGID で識別） |
| プロセスグループ                 | Process Group            | シグナル配送の単位となるプロセスの集合            |
| セッション                       | Session                  | 制御端末を共有するプロセスグループの集合          |
| セッションリーダー               | Session Leader           | setsid() を呼び出してセッションを作成したプロセス |
| 制御端末                         | Controlling Terminal     | セッションに関連付けられた端末                    |
| フォアグラウンドプロセスグループ | Foreground Process Group | 制御端末からの入力を受け取るプロセスグループ      |
| バックグラウンドプロセスグループ | Background Process Group | 端末と対話しないプロセスグループ                  |
| デーモン                         | Daemon                   | 端末から切り離されたバックグラウンドサービス      |
| 資格情報                         | Credentials              | プロセスの UID、GID、ケーパビリティなど           |
| ケーパビリティ                   | Capability               | 特定の特権操作を許可する粒度の細かい権限          |
| 実 UID                           | Real UID                 | プロセスを起動したユーザーの ID                   |
| 実効 UID                         | Effective UID            | 権限チェックに使用される UID                      |
| 保存 UID                         | Saved UID                | 一時的に権限を下げるための退避先                  |
| 補助グループ                     | Supplementary Groups     | プロセスが属する追加のグループ                    |
| ゾンビ                           | Zombie                   | 終了したが親が wait() していないプロセス          |
| 孤児プロセス                     | Orphan Process           | 親が先に終了したプロセス                          |
| subreaper                        | Subreaper                | 孤児プロセスの引き取り役となるプロセス            |
| clone                            | clone                    | プロセスまたはスレッドを作成するシステムコール    |
| TGID                             | Thread Group ID          | スレッドグループの識別子（メインスレッドの PID）  |
| TID                              | Thread ID                | 個々のスレッドの識別子                            |

---

## 参考資料

このページの内容は、以下のソースに基づいています

<strong>プロセス情報</strong>

- [proc(5) - Linux manual page](https://man7.org/linux/man-pages/man5/proc.5.html)
  - /proc ファイルシステム、/proc/[pid]/ 以下のファイル

<strong>資格情報</strong>

- [credentials(7) - Linux manual page](https://man7.org/linux/man-pages/man7/credentials.7.html)
  - プロセス識別子、資格情報、グループ

<strong>ケーパビリティ</strong>

- [capabilities(7) - Linux manual page](https://man7.org/linux/man-pages/man7/capabilities.7.html)
  - Linux のケーパビリティシステム

<strong>プロセス作成</strong>

- [fork(2) - Linux manual page](https://man7.org/linux/man-pages/man2/fork.2.html)
  - プロセスの複製
- [clone(2) - Linux manual page](https://man7.org/linux/man-pages/man2/clone.2.html)
  - 共有設定が可能なスレッド/プロセス作成

<strong>セッションとプロセスグループ</strong>

- [setsid(2) - Linux manual page](https://man7.org/linux/man-pages/man2/setsid.2.html)
  - 新しいセッションの作成
- [setpgid(2) - Linux manual page](https://man7.org/linux/man-pages/man2/setpgid.2.html)
  - プロセスグループ ID の設定

<strong>デーモンプロセス</strong>

- [daemon(7) - Linux manual page](https://man7.org/linux/man-pages/man7/daemon.7.html)
  - デーモンプログラムの書き方

<strong>プロセス終了</strong>

- [exit(2) - Linux manual page](https://man7.org/linux/man-pages/man2/exit.2.html)
  - プロセスの終了
- [wait(2) - Linux manual page](https://man7.org/linux/man-pages/man2/wait.2.html)
  - プロセスの状態変化を待つ
- [prctl(2) - Linux manual page](https://man7.org/linux/man-pages/man2/prctl.2.html)
  - PR_SET_CHILD_SUBREAPER

---

## 次のステップ

このトピックでは、カーネルがプロセスを「管理」する仕組みを学びました

- プロセスの状態と遷移
- プロセスグループとセッション
- デーモンプロセスの仕組み
- プロセスの作成と終了

しかし、1 つ疑問が残ります

複数のプロセスが同時に実行可能（R 状態）のとき、カーネルはどのプロセスに CPU を使わせるのでしょうか？

次の [05-scheduler](./05-scheduler.md) では、CPU という限られたリソースをプロセスに配分する「スケジューラ」の仕組みを学びます

- スケジューラは何を基準にプロセスを選ぶのか
- nice 値とは何か
- リアルタイムプロセスとは
- /proc/[pid]/sched から読み取れる情報

これらの疑問に答えます
