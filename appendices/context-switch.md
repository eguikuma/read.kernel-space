<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# CPUは複数のプロセスをどう切り替えるのか

## はじめに

[05-scheduler](../05-scheduler.md) では、カーネルのスケジューラが CPU 時間をプロセスに配分する仕組みを学びました

しかし、「プロセスを切り替える」とは、具体的に何をしているのでしょうか？

1 つの CPU は、同時に 1 つのプログラムしか実行できません

にもかかわらず、複数のプログラムが「同時に」動いているように見えるのはなぜでしょうか？

その答えが<strong>コンテキストスイッチ</strong>です

このドキュメントでは、CPU がプロセスを切り替えるときに何が起きているかを説明します

---

## 目次

- [コンテキストとは](#コンテキストとは)
- [コンテキストスイッチの仕組み](#コンテキストスイッチの仕組み)
- [自発的と非自発的](#自発的と非自発的)
- [コンテキストスイッチのオーバーヘッド](#コンテキストスイッチのオーバーヘッド)
- [コンテキストスイッチの確認方法](#コンテキストスイッチの確認方法)
- [まとめ](#まとめ)
- [参考資料](#参考資料)

---

## コンテキストとは

### プロセスの「状態」

<strong>コンテキスト</strong>とは、プロセスの「現在の状態」を表す情報の集まりです

日常の例えで言えば、本を読んでいるときの「しおり」と「今読んでいるページ」のようなものです

読書を中断して別の本を読み、また元の本に戻るとき、「どこまで読んだか」を覚えておく必要があります

CPU も同じで、プロセスを切り替えるときに「どこまで実行したか」を保存・復元する必要があります

### コンテキストに含まれる情報

| 情報                   | 説明                       |
| ---------------------- | -------------------------- |
| プログラムカウンタ     | 次に実行する命令のアドレス |
| CPU レジスタ           | 計算中の値、アドレスなど   |
| スタックポインタ       | スタックの現在位置         |
| ページテーブルポインタ | 仮想メモリのマッピング情報 |
| プロセス状態           | R、S、D などの状態         |

### なぜコンテキストを保存するのか

CPU レジスタは非常に高速ですが、数は限られています（x86_64 で汎用レジスタは 16 個）

すべてのプロセスが同じレジスタを使うため、切り替え時に内容を保存しないと、前のプロセスの計算結果が失われます

---

## コンテキストスイッチの仕組み

### 切り替えの流れ

```
1. 現在のプロセス（A）の実行を中断
2. プロセス A のコンテキストをメモリに保存
3. 次のプロセス（B）のコンテキストをメモリから復元
4. プロセス B の実行を再開
```

### より詳細な流れ

<strong>1. 割り込みまたはシステムコールの発生</strong>

- タイマー割り込み（時間切れ）
- I/O 完了割り込み
- システムコール（sleep、read など）

<strong>2. ユーザーモードからカーネルモードへ移行</strong>

- CPU の特権レベルが変わる
- カーネルスタックに切り替わる

<strong>3. 現在のコンテキストを保存</strong>

- レジスタの内容をプロセス記述子に保存
- ユーザースタックポインタを保存

<strong>4. スケジューラが次のプロセスを選択</strong>

- 実行可能なプロセスの中から選ぶ
- CFS なら vruntime が最小のプロセス

<strong>5. 次のプロセスのコンテキストを復元</strong>

- プロセス記述子からレジスタを復元
- ページテーブルを切り替え（TLB フラッシュ）

<strong>6. カーネルモードからユーザーモードへ移行</strong>

- 新しいプロセスの実行を再開

### ページテーブルの切り替え

コンテキストスイッチでは、<strong>ページテーブル</strong>も切り替わります

<strong>なぜページテーブルを切り替えるのか</strong>

各プロセスは独自の<strong>仮想アドレス空間</strong>を持ちます

これは「プロセス A とプロセス B が同じアドレス 0x1000 を使っても、実際には別の物理メモリを指す」ことを意味します

```
プロセス A のページテーブル
仮想 0x1000 → 物理 0xA000

プロセス B のページテーブル
仮想 0x1000 → 物理 0xB000  ← 同じ仮想アドレスでも物理は異なる
```

この仕組みにより、プロセス同士が互いのメモリを勝手に読み書きできなくなり、セキュリティと安定性が確保されます

プロセスが変われば「仮想→物理」の変換表も変わるため、ページテーブルを切り替える必要があります

<strong>TLB フラッシュとは</strong>

TLB（Translation Lookaside Buffer）は、ページテーブルの検索結果をキャッシュする CPU 内部の高速メモリです（詳細は [page.md](./page.md#tlbとは) を参照）

ページテーブルを切り替えると、TLB の内容は「古いプロセスの変換結果」なので、無効化（フラッシュ）する必要があります

これが、コンテキストスイッチのオーバーヘッドの主な原因です

---

## 自発的と非自発的

### 2種類のコンテキストスイッチ

コンテキストスイッチには、2 種類あります

| 種類     | 英語        | トリガー                     |
| -------- | ----------- | ---------------------------- |
| 自発的   | Voluntary   | プロセス自身が CPU を手放す  |
| 非自発的 | Involuntary | カーネルが強制的に切り替える |

### 自発的コンテキストスイッチ

プロセスが<strong>自ら CPU を手放す</strong>場合です

| トリガー          | 説明                  |
| ----------------- | --------------------- |
| I/O 待ち          | read() でデータを待つ |
| sleep()           | 明示的な待機          |
| mutex / semaphore | ロック待ち            |
| ネットワーク待ち  | recv() でデータを待つ |

プロセスが S（Interruptible Sleep）や D（Uninterruptible Sleep）状態になります

### 非自発的コンテキストスイッチ

カーネルが<strong>強制的に切り替える</strong>場合です

| トリガー               | 説明                                 |
| ---------------------- | ------------------------------------ |
| タイムスライス消費     | 割り当て時間を使い切った             |
| 高優先度プロセスの起床 | より優先度の高いプロセスが実行可能に |
| CPU アフィニティ変更   | 別の CPU に移動させられた            |

この場合、プロセスは R 状態のまま「実行可能だが待機中」になります

### 確認方法

```bash
# /proc/[pid]/status で確認
grep ctxt /proc/self/status
```

出力例

```
voluntary_ctxt_switches:        150
nonvoluntary_ctxt_switches:     10
```

---

## コンテキストスイッチのオーバーヘッド

### 何がコストになるのか

コンテキストスイッチには、以下のコストがあります

| コスト               | 説明               |
| -------------------- | ------------------ |
| レジスタの保存・復元 | 数十〜数百サイクル |
| TLB フラッシュ       | 数百〜数千サイクル |
| CPU キャッシュミス   | 数千〜数万サイクル |
| スケジューラの実行   | 数百サイクル       |

### TLBフラッシュの影響

ページテーブルが切り替わると、TLB の内容が無効になります

新しいプロセスが実行を再開すると、TLB ミスが多発し、ページテーブルの参照が必要になります

これが、コンテキストスイッチで最も大きなオーバーヘッドです

<strong>TLB フラッシュの実装</strong>

x86_64 では、ページテーブルの切り替えは CR3 レジスタへの書き込みで行います

```
/* CR3 レジスタに新しいページテーブルのアドレスを設定 */
mov cr3, 新しいページテーブルの物理アドレス
/* → この瞬間、TLB 全体が無効化される（従来の動作） */
```

4 段ページテーブルの場合、TLB ミスが発生すると最大 4 回のメモリアクセスが必要になります

<strong>PCID（Process Context ID）による最適化</strong>

従来は CR3 を書き換えるたびに TLB 全体がフラッシュされていました

しかし Intel Westmere（2010 年）以降では、<strong>PCID</strong> という機能で TLB フラッシュを回避できます

| 機能 | 説明                                                     |
| ---- | -------------------------------------------------------- |
| PCID | 各 TLB エントリに 12 ビットの「プロセス ID」タグを付ける |
| 効果 | プロセス切り替え時も TLB を保持、タグで区別              |
| 制限 | 最大 4096 個のプロセスを同時にタグ付け可能               |

```
TLB エントリ（PCID 有効時）
┌───────────┬───────────────┬───────────────┐
│ PCID (12) │ 仮想ページ番号 │ 物理ページ番号 │
└───────────┴───────────────┴───────────────┘
```

PCID が有効な場合、CR3 への書き込み時に「フラッシュしない」フラグを設定できます

Linux カーネル 4.14 以降で PCID サポートが改善され、コンテキストスイッチのオーバーヘッドが大幅に削減されました

<strong>ARM の ASID</strong>

ARM プロセッサでは、同様の機能が<strong>ASID（Address Space ID）</strong>と呼ばれます

8 ビット（256 プロセス）または 16 ビット（65536 プロセス）のタグが使用されます

<strong>Lazy TLB フラッシュ</strong>

カーネルスレッドは独自のページテーブルを持たず、前のプロセスのページテーブルを「借りて」動作します

この場合、TLB フラッシュは不要です（Lazy TLB）

```
ユーザープロセス A → カーネルスレッド → ユーザープロセス B
                     │
                     └── A のページテーブルを借用
                         TLB フラッシュなし
```

### CPUキャッシュの影響

切り替え後のプロセスは、前のプロセスのデータで埋まった CPU キャッシュを使います

必要なデータがキャッシュにないため、メモリアクセスが遅くなります

### オーバーヘッドの目安

| 環境                             | 時間               |
| -------------------------------- | ------------------ |
| 直接的なコスト                   | 1〜10 マイクロ秒   |
| 間接的なコスト（キャッシュミス） | 10〜100 マイクロ秒 |

頻繁なコンテキストスイッチは、システム全体のパフォーマンスを低下させます

---

## コンテキストスイッチの確認方法

### /proc/[pid]/status

```bash
grep ctxt /proc/self/status
```

### /proc/[pid]/sched

より詳細なスケジューリング統計を確認できます

```bash
cat /proc/self/sched
```

出力例

```
...
nr_switches                                  :                  100
nr_voluntary_switches                        :                   90
nr_involuntary_switches                      :                   10
...
```

### vmstat コマンド

システム全体のコンテキストスイッチ数を確認できます

```bash
vmstat 1
```

出力例

```
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 8000000 100000 2000000    0    0     0     0  100  500  5  2 93  0  0
```

`cs` 列がコンテキストスイッチ数（1秒あたり）です

### perf コマンド

詳細なプロファイリングが可能です

```bash
# コンテキストスイッチをカウント
perf stat -e context-switches sleep 1

# コンテキストスイッチを記録
perf record -e context-switches ./myapp
perf report
```

---

## まとめ

<strong>コンテキストスイッチとは</strong>

| ポイント                           | 説明                                 |
| ---------------------------------- | ------------------------------------ |
| プロセスの状態を保存・復元         | レジスタ、スタック、ページテーブル   |
| CPU が複数プロセスを実行する仕組み | 高速な切り替えで「同時実行」に見せる |

<strong>覚えておくこと</strong>

| ポイント       | 説明                                     |
| -------------- | ---------------------------------------- |
| 自発的         | I/O 待ちなどでプロセス自身が手放す       |
| 非自発的       | タイムスライス消費などでカーネルが強制   |
| オーバーヘッド | TLB フラッシュとキャッシュミスが主な原因 |
| 確認方法       | /proc/[pid]/status、vmstat、perf         |

---

## 参考資料

<strong>Linux マニュアル</strong>

- [proc(5) - Linux manual page](https://man7.org/linux/man-pages/man5/proc.5.html)
  - /proc/[pid]/status、/proc/[pid]/sched
- [sched(7) - Linux manual page](https://man7.org/linux/man-pages/man7/sched.7.html)
  - スケジューリングの概要

<strong>コマンド</strong>

- [vmstat(8) - Linux manual page](https://man7.org/linux/man-pages/man8/vmstat.8.html)
  - システム統計の表示
- [perf(1) - Linux manual page](https://man7.org/linux/man-pages/man1/perf.1.html)
  - パフォーマンス分析ツール

<strong>本編との関連</strong>

- [02-syscall](../02-syscall.md)
  - システムコールとモード切り替え
- [05-scheduler](../05-scheduler.md)
  - スケジューラとプロセス切り替え
