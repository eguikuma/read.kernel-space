<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# 01-kernel：カーネルとは何か

## はじめに

前のシリーズでは、OS がプログラムを動かす仕組みを「使う側」の視点で学びました

- プロセスとは何か
- fork/exec でプロセスを作る方法
- シグナルでプロセスに通知する方法
- スレッドで並行処理する方法
- ファイルディスクリプタで OS がファイルを管理する仕組み
- 標準入出力の仕組み
- プロセス間通信の方法

これらはすべて、普段私たちが書くプログラムが動く場所で起きていることでした

この「プログラムが動く場所」のことを<strong>ユーザー空間</strong>と呼びます（詳しくはこのページで説明します）

では、プログラムが `fork()` を呼んだとき、OS の中では何が起きているのでしょうか？

このページでは、OS の「心臓部」である<strong>カーネル</strong>について学びます

### 日常の例え

コンピュータを「会社」に例えてみましょう

普段私たちが書く<strong>プログラム</strong>は「社員」です

社員は自分の仕事（計算処理など）はできますが、会社のリソース（会議室、備品、経費など）を直接使うことはできません

なぜなら、もし社員が勝手に金庫を開けたり、受付を操作したりできたら、会社全体が混乱するからです

だから、リソースを使いたいときは必ず「総務部」を通す必要があります

<strong>カーネル</strong>は、その「総務部」に相当します

- 社員（プログラム）が「会議室を使いたい」と言うと、総務部（カーネル）が空き状況を確認して予約する
- 社員が「経費を使いたい」と言うと、総務部が予算を確認して承認する
- 社員が「新しい備品が欲しい」と言うと、総務部が購入を手配する

社員は総務部に「お願い」をするだけで、実際の手続きは総務部が行います

この「総務部にお願いする手続き」のことを「システムコール」と呼びます

### このページで学ぶこと

このページでは、以下の概念を学びます

- <strong>カーネルとは何か</strong>
  - OS の中核として、何を担当しているか
- <strong>カーネル空間とユーザー空間</strong>
  - なぜ2つの「空間」に分かれているのか
- <strong>カーネルが提供する主要な機能</strong>
  - プロセス管理、メモリ管理、ファイルシステム、デバイス管理
- <strong>/proc ファイルシステム</strong>
  - カーネルの情報を「観察」する窓口
- <strong>/sys ファイルシステム</strong>
  - デバイスやサブシステムの情報を提供する疑似ファイルシステム
- <strong>カーネル情報の取得方法</strong>
  - uname()、sysinfo() などのシステムコール

---

## 目次

1. [カーネルとは何か](#カーネルとは何か)
2. [カーネル空間とユーザー空間](#カーネル空間とユーザー空間)
3. [カーネルが提供する主要な機能](#カーネルが提供する主要な機能)
4. [カーネルの情報を取得する](#カーネルの情報を取得する)
5. [/proc ファイルシステム](#proc-ファイルシステム)
6. [/sys ファイルシステム](#sys-ファイルシステム)
7. [カーネルモジュール](#カーネルモジュール)
8. [用語集](#用語集)
9. [参考資料](#参考資料)

---

## カーネルとは何か

### 基本的な説明

<strong>カーネル（Kernel）</strong>は、OS の中核となるプログラムです

「Kernel」は英語で「核」や「中心」を意味します

Linux の公式ドキュメントには、カーネルの役割として以下が挙げられています

- <strong>ハードウェアの抽象化</strong>
  - 「抽象化」とは、複雑な詳細を隠して、シンプルに使えるようにすること
  - 例えば、ファイルを読むとき、「ディスクのどのセクタから読むか」を意識する必要がない
  - カーネルが詳細を隠してくれるので、`read()` を呼ぶだけでファイルが読める
- <strong>リソースの管理</strong>
  - 複数のプログラムが同時に動いても、互いに干渉しないようにリソースを管理する
- <strong>プロセスの管理</strong>
  - プログラムの起動、終了、切り替えを行う
- <strong>セキュリティの確保</strong>
  - プログラムが許可されていない操作を行わないように監視する

### カーネルがないとどうなるか

カーネルがなければ、プログラムは

- ハードウェアを直接操作しなければならない
- 他のプログラムと協調する方法がない
- メモリを好き勝手に使って、他のプログラムを壊す可能性がある

カーネルは、これらの問題を解決するために存在します

---

## カーネル空間とユーザー空間

### なぜ2つの空間に分かれているのか

コンピュータのメモリは、大きく2つの領域に分かれています

| 空間                         | 説明                           |
| ---------------------------- | ------------------------------ |
| カーネル空間（Kernel Space） | OS の中核が動作する領域        |
| ユーザー空間（User Space）   | 一般のプログラムが動作する領域 |

この分離には、重要な理由があります

### セキュリティと安定性

<strong>1. プログラムの暴走を防ぐ</strong>

もしプログラムがカーネル空間に自由にアクセスできたら、以下の問題が起こります

- バグのあるプログラムが OS を壊す
- 悪意のあるプログラムが他のプログラムのデータを盗む
- 1つのプログラムのクラッシュが、システム全体をダウンさせる

<strong>2. CPU の特権レベルで分離</strong>

「2つに分かれています」と言いましたが、これは単なるルールではありません

<strong>CPU 自体に、この分離を強制する仕組みが組み込まれています</strong>

CPU には「特権レベル」という機能があり、プログラムが勝手にハードウェアを操作することを防いでいます

- <strong>特権モード（カーネルモード）</strong>
  - 「特権モード」と「カーネルモード」は同じものを指す別名です
  - ハードウェアを操作する処理（例：ディスクにデータを書き込む）を実行できる
  - カーネルだけがこのモードで動く
- <strong>ユーザーモード</strong>
  - 通常の計算処理はできるが、ハードウェアを直接操作することは禁止されている
  - 禁止された操作をしようとすると、CPU がエラーを発生させる

ユーザー空間のプログラムは「ユーザーモード」で動作し、カーネルは「特権モード」で動作します

### システムコールによる橋渡し

ユーザー空間のプログラムがカーネルの機能を使いたいとき、<strong>システムコール</strong>を使います

しかし、なぜプログラムは直接ハードウェアを操作できないのでしょうか？

先ほど説明した「CPU の特権レベル」を思い出してください

ユーザー空間のプログラムは「ユーザーモード」で動作しています

ユーザーモードでは、ハードウェアを直接操作する命令は <strong>CPU によって禁止されています</strong>

例えば、ディスクにデータを書き込む命令を実行しようとすると、CPU がエラー（例外）を発生させ、プログラムは強制終了されます

これは、セキュリティと安定性を守るための設計です

もしプログラムが自由にディスクを操作できたら、他のプログラムのファイルを勝手に書き換えたり、OS 自体を壊したりできてしまいます

では、ファイルを読み書きするにはどうすればよいのでしょうか？

答えは「カーネルにお願いする」ことです

「`read()` を呼び出す」→「カーネルがディスクからデータを取得」→「結果をプログラムに返す」という流れになります

この「カーネルにお願いする」仕組みがシステムコールです

Linux の公式マニュアルには、こう書かれています

> The system call is the fundamental interface between an application and the Linux kernel.

> システムコールは、アプリケーションと Linux カーネル間の基本的なインターフェースです

システムコールの詳しい仕組みは、次のトピック [02-syscall](./02-syscall.md) で学びます

---

## カーネルが提供する主要な機能

カーネルは、以下の主要な機能を提供しています

### 1. プロセス管理

プログラムの実行を管理します

- プロセスの作成と終了
- プロセス間の切り替え（スケジューリング）
- プロセスの状態管理

前のシリーズで学んだ `fork()`、`exec()`、`wait()` などは、すべてカーネルのプロセス管理機能を利用しています

### 2. メモリ管理

メモリの割り当てと保護を行います

- 物理メモリの管理
- 仮想メモリの提供
- プロセスごとのメモリ空間の分離

前のシリーズで学んだ「プロセスごとに独立したメモリ空間がある」という特性は、カーネルのメモリ管理機能によって実現されています

### 3. ファイルシステム

ファイルやディレクトリへのアクセスを管理します

- ファイルの読み書き
- ディレクトリの操作
- アクセス権限のチェック

前のシリーズで学んだファイルディスクリプタは、カーネルが管理しています

### 4. デバイス管理

ハードウェアへのアクセスを抽象化します

- デバイスドライバ（ハードウェアを制御するプログラム）の管理
- デバイスへのアクセス制御
- 入出力の処理

### 5. ネットワーク

ネットワーク通信を処理します

- TCP/IP プロトコルスタック
- ソケット通信
- ネットワークインターフェースの管理

---

## カーネルの情報を取得する

カーネルに関する情報を取得するには、いくつかの方法があります

### uname() システムコール

`uname()` は、カーネルのバージョンやシステム情報を取得するシステムコールです

Linux の公式マニュアルには、こう書かれています

> uname() returns system information in the structure pointed to by buf.

> uname() は、buf が指す構造体にシステム情報を返します

`uname()` で取得できる情報

| フィールド | 説明                                              |
| ---------- | ------------------------------------------------- |
| sysname    | OS の名前（例：Linux）                            |
| nodename   | ホスト名（ネットワーク上でのコンピュータの名前）  |
| release    | カーネルのリリースバージョン（例：6.5.0-generic） |
| version    | カーネルのビルド情報                              |
| machine    | ハードウェアの種類（例：x86_64）                  |

ターミナルで `uname -a` コマンドを実行すると、これらの情報を確認できます

### sysinfo() システムコール

`sysinfo()` は、システム全体の統計情報を取得するシステムコールです

Linux の公式マニュアルには、こう書かれています

> sysinfo() returns certain statistics on memory and swap usage, as well as the load average.

> sysinfo() は、メモリやスワップの使用状況、およびロードアベレージの統計情報を返します

ここで登場する「スワップ」と「ロードアベレージ」について説明します

<strong>スワップ：メモリ不足への備え</strong>

コンピュータで複数のプログラムを同時に動かすと、物理メモリ（RAM）が足りなくなることがあります

もしメモリが完全に枯渇したら、プログラムは新しいメモリを確保できず、動作を続けられなくなります

この問題を解決するのが<strong>スワップ</strong>です

スワップとは、ディスクの一部を「臨時のメモリ」として使う仕組みです

メモリが足りなくなったとき、使われていないデータを一時的にディスクに退避（スワップアウト）し、メモリを空けます

ディスクは RAM より遅いので、スワップを使うとシステムは遅くなりますが、「完全に止まる」よりはましです

スワップの詳しい仕組みは [appendices/swap.md](./appendices/swap.md) で学べます

<strong>ロードアベレージ：システムの忙しさを数値化する</strong>

「今、システムはどれくらい忙しいのか？」を知りたいとき、どうすればよいでしょうか？

ロードアベレージは、この疑問に答える数値です

具体的には、<strong>「CPU を使いたい状態」または「ディスク I/O を待っている状態」のプロセスが平均何個あるか</strong>を示します

値が高いほど、システムが忙しい状態です

例えば、CPU が 4 コアのシステムでは、ロードアベレージが 4.0 なら「4 つの CPU がフル稼働している」状態、8.0 なら「CPU の処理能力を超えて待ち行列ができている」状態を意味します

ロードアベレージの詳しい計算方法や解釈は [appendices/load-average.md](./appendices/load-average.md) で学べます

`sysinfo()` で取得できる情報

| フィールド | 説明                             |
| ---------- | -------------------------------- |
| uptime     | システムが起動してからの経過秒数 |
| loads      | 1分、5分、15分のロードアベレージ |
| totalram   | 物理メモリの総量                 |
| freeram    | 空き物理メモリ                   |
| procs      | 現在のプロセス数                 |

### gethostname() システムコール

`gethostname()` は、現在のホスト名を取得するシステムコールです

Linux の公式マニュアルには、こう書かれています

> gethostname() returns the null-terminated hostname in the character array name.

> gethostname() は、ホスト名を文字配列 name に返します

---

## /proc ファイルシステム

### /proc とは

`/proc` は、カーネルの情報を「ファイル」の形式で見せてくれる特別な場所です

通常のファイル（テキストファイルなど）はディスクに保存されていて、一度書いた内容は書き換えない限り同じままです

しかし `/proc` は違います

Linux の公式マニュアルには、こう書かれています

> The proc filesystem is a pseudo-filesystem which provides an interface to kernel data structures.

> proc ファイルシステムは、カーネルの内部情報を読み取るための窓口を提供する疑似ファイルシステムです

このように「ファイルのふりをしているが、実体はない」ものを<strong>疑似ファイルシステム</strong>と呼びます

### /proc の特徴

- <strong>ディスク上に存在しない</strong>
  - `/proc` の中身は、ディスクに保存されていない
  - カーネルが「今この瞬間の情報」をリアルタイムで生成している
- <strong>読み取るたびに最新の情報</strong>
  - 例えば `/proc/uptime`（システム稼働時間）を読むと、読んだ瞬間の稼働時間が返ってくる
  - 1秒後に読めば、1秒増えた値が返ってくる
- <strong>一部は書き込み可能</strong>
  - カーネルの設定を変更できるファイルもある

### /proc の主要なファイル・ディレクトリ

| パス              | 説明                                       |
| ----------------- | ------------------------------------------ |
| /proc/[pid]/      | 各プロセスの情報（PID ごとのディレクトリ） |
| /proc/self/       | 自分自身のプロセス情報へのリンク           |
| /proc/version     | カーネルのバージョン情報                   |
| /proc/uptime      | システムの稼働時間                         |
| /proc/loadavg     | ロードアベレージ                           |
| /proc/meminfo     | メモリの使用状況                           |
| /proc/cpuinfo     | CPU の情報                                 |
| /proc/cmdline     | カーネルの起動パラメータ                   |
| /proc/modules     | ロード済みのカーネルモジュール             |
| /proc/stat        | カーネルの統計情報                         |
| /proc/filesystems | サポートされているファイルシステム         |

### /proc の使い方

<strong>カーネルバージョンの確認</strong>

```bash
cat /proc/version
```

出力例

```
Linux version 6.5.0-generic (buildd@lcy02-amd64-051) ...
```

<strong>システム稼働時間の確認</strong>

```bash
cat /proc/uptime
```

出力例

```
12345.67 98765.43
```

1つ目の数値がシステムの稼働秒数、2つ目がアイドル時間（CPU が何も処理していない時間）の合計です

<strong>メモリ使用状況の確認</strong>

```bash
cat /proc/meminfo
```

---

## /sys ファイルシステム

### /sys とは

`/proc` とは別に、`/sys` という疑似ファイルシステムもあります

両者の違いを簡単に言うと

| ファイルシステム | 主な目的                             |
| ---------------- | ------------------------------------ |
| /proc            | プロセス情報とカーネルの統計情報     |
| /sys             | ハードウェア（デバイス）の情報と設定 |

例えば、「接続されているディスクの情報」や「ネットワークカードの設定」は `/sys` で確認できます

なぜ2つに分かれているのでしょうか？

歴史的な理由があります

最初は `/proc` にすべての情報が入っていましたが、情報が増えすぎて整理が難しくなりました

そこで、デバイス関連の情報を `/sys` に分離することで、より整理された形で情報を提供するようになりました

Linux の公式ドキュメントでは、`/sys` は「sysfs」と呼ばれています

### /sys の主要なディレクトリ

| パス          | 説明                                     |
| ------------- | ---------------------------------------- |
| /sys/block/   | ブロックデバイス（ディスクなど）の情報   |
| /sys/class/   | デバイスクラス（ネットワーク、入力など） |
| /sys/devices/ | 物理デバイスの階層構造                   |
| /sys/fs/      | ファイルシステム関連の情報               |
| /sys/kernel/  | カーネル全体の設定                       |
| /sys/module/  | ロード済みモジュールのパラメータ         |

### /sys/fs/cgroup

`/sys/fs/cgroup` は、コントロールグループ（cgroup）の設定と情報を提供します

cgroup は、プロセスのリソース（CPU、メモリなど）を制限する仕組みで、コンテナ技術の基盤となっています

cgroup の詳細は [07-cgroup](./07-cgroup.md) で学びます

---

## カーネルモジュール

### カーネルモジュールとは

<strong>カーネルモジュール</strong>は、カーネルに動的に追加できる機能です

通常、カーネルは起動時に読み込まれ、変更するには再起動が必要です

しかし、カーネルモジュールを使えば、再起動せずに機能を追加・削除できます

### なぜカーネルモジュールがあるのか

カーネルモジュールの仕組みを理解するには、まず「もしカーネルモジュールがなかったら？」を考えてみましょう

<strong>歴史的背景：メモリが貴重だった時代</strong>

Linux が登場した頃、コンピュータのメモリは非常に高価でした

当時の一般的な PC のメモリは 4〜16 MB 程度でした（現代のスマートフォンは 4〜8 GB 程度）

もしカーネルにすべてのドライバ（ハードウェアを制御するプログラム）を組み込んだら、カーネルだけで貴重なメモリを大量に消費してしまいます

例えば、プリンタ、サウンドカード、ネットワークカード、USB デバイス...世の中にはたくさんのハードウェアがあります

しかし、ある特定のコンピュータに接続されるハードウェアは、その一部だけです

使いもしないドライバのためにメモリを消費するのは、非効率です

<strong>カーネルモジュールによる解決</strong>

そこで考案されたのが「カーネルモジュール」という仕組みです

<strong>1. 必要なときだけロード</strong>

すべてのドライバやファイルシステムを最初からカーネルに組み込む代わりに、必要なときだけメモリにロードできます

例えば、USB メモリを挿したときに初めて USB ドライバがロードされ、取り外したらアンロードできます

<strong>2. 開発が容易</strong>

新しいドライバを開発するとき、カーネル全体を再コンパイルする必要がありません

モジュールだけをコンパイルしてロードすれば、テストできます

再起動も不要なので、開発のサイクルが大幅に短縮されます

### カーネルモジュールの確認

<strong>ロード済みモジュールの一覧</strong>

```bash
lsmod
```

<strong>/proc/modules からの確認</strong>

```bash
cat /proc/modules
```

---

## 用語集

| 用語                 | 英語              | 説明                                                     |
| -------------------- | ----------------- | -------------------------------------------------------- |
| カーネル             | Kernel            | OS の中核となるプログラム                                |
| カーネル空間         | Kernel Space      | カーネルが動作するメモリ領域                             |
| ユーザー空間         | User Space        | 一般のプログラムが動作するメモリ領域                     |
| 特権モード           | Privileged Mode   | ハードウェアを直接操作できるモード                       |
| ユーザーモード       | User Mode         | ハードウェアを直接操作できないモード                     |
| システムコール       | System Call       | ユーザー空間からカーネルに処理を依頼する仕組み           |
| 疑似ファイルシステム | Pseudo Filesystem | ディスク上に存在しない仮想的なファイルシステム           |
| /proc                | /proc             | プロセスとカーネル情報を提供する疑似ファイルシステム     |
| /sys                 | /sys              | デバイスとサブシステム情報を提供する疑似ファイルシステム |
| カーネルモジュール   | Kernel Module     | カーネルに動的に追加できる機能                           |
| デバイスドライバ     | Device Driver     | ハードウェアを制御するプログラム                         |
| スワップ             | Swap              | ディスクをメモリの代わりに使う仕組み                     |
| ロードアベレージ     | Load Average      | システムの負荷を表す数値                                 |
| ホスト名             | Hostname          | ネットワーク上でのコンピュータの名前                     |
| プロトコルスタック   | Protocol Stack    | ネットワーク通信の階層化された処理                       |
| cgroup               | Control Group     | プロセスのリソースを制限する仕組み                       |

---

## 参考資料

このページの内容は、以下のソースに基づいています

<strong>システムコール</strong>

- [uname(2) - Linux manual page](https://man7.org/linux/man-pages/man2/uname.2.html)
  - システム情報の取得
- [sysinfo(2) - Linux manual page](https://man7.org/linux/man-pages/man2/sysinfo.2.html)
  - メモリやプロセスの統計情報
- [gethostname(2) - Linux manual page](https://man7.org/linux/man-pages/man2/gethostname.2.html)
  - ホスト名の取得

<strong>疑似ファイルシステム</strong>

- [proc(5) - Linux manual page](https://man7.org/linux/man-pages/man5/proc.5.html)
  - /proc ファイルシステム
- [sysfs(5) - Linux manual page](https://man7.org/linux/man-pages/man5/sysfs.5.html)
  - /sys ファイルシステム

<strong>カーネルドキュメント</strong>

- [The Linux Kernel documentation](https://www.kernel.org/doc/html/latest/)
  - カーネルの公式ドキュメント

---

## 次のステップ

このトピックでは、カーネルとは何か、そしてカーネルの情報を「観察」する方法を学びました

次の [02-syscall](./02-syscall.md) では、ユーザー空間からカーネルに処理を依頼する「システムコール」の仕組みを詳しく学びます

- システムコールはどのように動作するのか
- ライブラリ関数とシステムコールの違い
- strace でシステムコールを観察する方法

これらの疑問に答えます
