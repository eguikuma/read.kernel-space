<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# ディスクはどうやってファイルになるのか

## はじめに

[filesystem](./filesystem.md) で、ファイルの正体は inode であり、データはブロック単位でディスクに保存されると学びました

しかし、そもそも「ブロック」とは何でしょうか？

ディスクは最初からファイルを保存できるのでしょうか？

答えは<strong>「いいえ」</strong>です

新品のディスクは、ただのバイト列の塊です

「ファイル」という概念を使えるようにするには、3 つのステップが必要です

```
ブロックデバイス → ファイルシステムの作成 → マウント
（ディスク）       （管理構造の書き込み）    （ディレクトリツリーへの接続）
```

このドキュメントでは、ディスクがファイルとして使えるようになるまでの仕組みを説明します

---

## 目次

- [ブロックデバイスとは](#ブロックデバイスとは)
- [「空のブロックデバイス」とは](#空のブロックデバイスとは)
- [ファイルシステムの作成（mkfs）](#ファイルシステムの作成mkfs)
- [マウント：ディレクトリツリーへの接続](#マウントディレクトリツリーへの接続)
- [なぜ3層に分離されているのか](#なぜ3層に分離されているのか)
- [ファイルシステムのシグネチャとwipefs](#ファイルシステムのシグネチャとwipefs)
- [確認方法](#確認方法)
- [用語集](#用語集)
- [まとめ](#まとめ)
- [参考資料](#参考資料)

---

## ブロックデバイスとは

### デバイスの2つの種類

Linux のデバイスは、大きく 2 種類に分かれます

<strong>キャラクタデバイス</strong>

データが「流れ」として届くデバイスです

```
キーボード → 「a」を1文字打つ → 1文字ずつOSに届く
マウス     → 動かすたびに座標が1つずつ届く
```

1 バイトずつ、順番にデータをやり取りします

<strong>ブロックデバイス</strong>

データを「かたまり」単位でやり取りするデバイスです

```
SSD → 「このかたまり（4KB）をまとめて読んで」と指示
    → かたまり単位でデータが返ってくる
```

HDD、SSD、USB メモリなどのストレージが、ブロックデバイスです

### なぜ「かたまり」単位なのか

これはハードウェアの物理的な制約です

<strong>HDD の場合</strong>

HDD は磁気ディスクが回転しており、ヘッドが 1 バイトだけ読むことができません

必ず<strong>セクタ</strong>という最小単位（通常 512 バイト）で読み取ります

<strong>SSD の場合</strong>

SSD の内部はフラッシュメモリで構成されており、ページ単位（4KB）で読み書きします

この「かたまり」がブロックです

### メモリのページサイズとの関係

ブロックの典型的なサイズは 4KB で、これはメモリのページサイズと同じです

```
メモリ（RAM）    → 4KB = 「ページ」   ← メモリの管理単位
ディスク（SSD）  → 4KB = 「ブロック」  ← ディスクの管理単位
                          ↑
                    偶然ではなく、意図的に同じサイズ
```

ディスクから 4KB のブロックを読むと、メモリの 4KB のページにそのまま載せられます

サイズが一致しているので変換が不要で、効率的な I/O が可能です

詳しくは [page](./page.md) の「なぜ4KBなのか」を参照してください

### Linux での表現

Linux はブロックデバイスを `/dev/` 以下のファイルとして表現します

```
/dev/sda   ← 1台目のディスク全体
/dev/sda1  ← 1台目のディスクのパーティション1
/dev/sda2  ← 1台目のディスクのパーティション2
/dev/sdb   ← 2台目のディスク全体
/dev/nvme0n1   ← NVMe SSD
```

ファイルとして表現されますが、中身はディスクそのものへのアクセス口です

### ブロックデバイスのイメージ

```
物理的なSSD（例：256GB）
┌────────────────────────────────────────────────┐
│                                                │
│  ブロック0  ブロック1  ブロック2  ブロック3 ...  │
│  [4KB]     [4KB]     [4KB]     [4KB]           │
│                                                │
│  ... ブロック67,108,863                         │
│      （256GB ÷ 4KB = 約6700万ブロック）          │
└────────────────────────────────────────────────┘
            ↑
    Linux からは /dev/sda として見える
    「67,108,864個の箱が並んだ棚」のようなもの
```

---

## 「空のブロックデバイス」とは

### 「空」の意味

「空のブロックデバイス」の「空」は、「ディスクが存在しない」という意味ではありません

物理的なディスク（またはその一部）は存在しています

「空」とは、<strong>管理構造がない状態</strong>を指します

```
「空のブロックデバイス」のイメージ

┌────────────────────────────────────────────────┐
│  [0000]  [0000]  [0000]  [0000]  [0000] ...   │
│  または                                        │
│  [????]  [????]  [????]  [????]  [????] ...   │
│                                                │
│  → 全ブロックがゼロ、またはランダムなゴミデータ  │
│  → 「ここはファイルAのデータ」などの管理情報なし  │
│  → ただの数字の羅列で、意味のある構造がない      │
└────────────────────────────────────────────────┘
```

箱は全部あるけど、中身が全部ゼロか白紙という状態です

「ファイル」という概念がまだ存在しないため、`photo.jpg はどこ？` という問いは意味を持ちません

### ループバックデバイス

空のブロックデバイスを用意する方法は 2 つあります

<strong>方法 1：物理ディスクを接続する</strong>

未使用の HDD や SSD を接続すると、`/dev/sdb` などとして認識されます

<strong>方法 2：ループバックデバイスを使う</strong>

物理ディスクがなくても、ファイルを仮想的なブロックデバイスとして扱えます

Linux のマニュアルには、こう書かれています

> The loop device is a block device that maps its data blocks not to a physical device such as a hard disk or optical disk drive, but to the blocks of a regular file in a filesystem or to another block device.

> ループデバイスは、データブロックを物理デバイス（ハードディスクや光学ディスクドライブなど）ではなく、ファイルシステム上の通常のファイルや別のブロックデバイスのブロックに対応付けるブロックデバイスです

```bash
# 100MB のゼロ埋めファイルを作成
dd if=/dev/zero of=disk.img bs=1M count=100

# ファイルをブロックデバイスとして割り当て
sudo losetup /dev/loop0 disk.img
```

これで `disk.img` というファイルが `/dev/loop0` というブロックデバイスとして使えます

学習やテスト環境では、ループバックデバイスが便利です

---

## ファイルシステムの作成（mkfs）

### mkfs とは

空のブロックデバイスには管理構造がないため、ファイルを保存できません

<strong>mkfs</strong>（make filesystem）は、ブロックデバイスにファイルシステムの管理構造を書き込むコマンドです

Linux のマニュアルには、こう書かれています

> mkfs is used to build a Linux filesystem on a device, usually a hard disk partition.

> mkfs は、デバイス（通常はハードディスクパーティション）上に Linux ファイルシステムを構築するために使用されます

### mkfs が何をするか

`mkfs.ext4 /dev/sdb` を実行すると、空の箱の並びの上に「目次」「索引」「ページ番号」が書き込まれます

```
実行前：/dev/sdb （ただの箱の並び）
┌──────┬──────┬──────┬──────┬──────┬──────┬──────┬─────┐
│ 0000 │ 0000 │ 0000 │ 0000 │ 0000 │ 0000 │ 0000 │ ... │
└──────┴──────┴──────┴──────┴──────┴──────┴──────┴─────┘
  ↑
  何も管理構造がない
  「ブロック5番に何が入っている？」→ 分からない
  「photo.jpg はどこ？」→ そんな概念すらない
```

```
実行後：/dev/sdb （ファイルシステムの骨組みが書き込まれた）
┌────────────┬──────────┬────────────────┬──────────────┐
│スーパー     │ inode    │ データ         │              │
│ブロック     │ テーブル │ ブロック領域   │   ...        │
│            │          │                │              │
│「ext4です」 │ inode 1  │ [空き] [空き]  │              │
│「ブロック   │ inode 2  │ [空き] [空き]  │              │
│  サイズ4KB」│  (ルート │ [空き] [空き]  │              │
│「inode数   │ ディレクトリ)│            │              │
│  XXX個」   │ inode 3  │                │              │
│            │  ...     │                │              │
└────────────┴──────────┴────────────────┴──────────────┘
  ↑              ↑              ↑
  管理情報       ファイルの      ファイルの中身を
  （全体像）     メタデータ格納  格納する場所
                 場所
```

<strong>スーパーブロック</strong>

ファイルシステム全体の情報を保持します

「このディスクは ext4 形式で、ブロックサイズは 4KB で、inode は何個ある」といった全体像です

<strong>inode テーブル</strong>

ファイルのメタデータを格納する場所です

inode の詳細は [filesystem](./filesystem.md) の「ファイルの正体：inode」を参照してください

<strong>データブロック領域</strong>

ファイルの中身を格納する場所です

mkfs 直後はすべて「空き」です

### mkfs は「フォーマット」

「フォーマットする」「初期化する」という表現は、この mkfs の操作を指しています

空の棚に「ここは A の棚」「ここは B の棚」と仕切りを入れ、目次を作る作業に相当します

---

## マウント：ディレクトリツリーへの接続

### なぜマウントが必要なのか

mkfs でファイルシステムを作成しただけでは、まだファイルを使えません

Linux のマニュアルには、こう書かれています

> All files accessible in a Unix system are arranged in one big tree, the file hierarchy, rooted at /.
>
> These files can be spread out over several devices.
>
> The mount command serves to attach the filesystem found on some device to the big file tree.

> Unix システムでアクセス可能なすべてのファイルは、/ をルートとする 1 つの大きなツリー（ファイル階層）に配置されます
>
> これらのファイルは複数のデバイスに分散できます
>
> mount コマンドは、あるデバイス上のファイルシステムをこの大きなファイルツリーに接続するために使います

ファイルシステムが存在していても、ディレクトリツリーに接続されていなければ、`cd` や `ls` で辿り着く方法がありません

### マウント前の状態

```
Linux のディレクトリツリー（普段使っている世界）

        /
       ├── home/
       │   └── user/
       ├── etc/
       ├── var/
       └── mnt/          ← 空のディレクトリ（入口だけある）


/dev/sdb のファイルシステム（まだ孤立している）

    [ルートディレクトリ]
    └── (空)

    → 上のツリーのどこからもアクセスできない
    → 「cd」や「ls」で辿り着く方法がない
```

### mount コマンドの実行

```bash
mount /dev/sdb /mnt
```

このコマンドは、カーネルに「`/dev/sdb` 上のファイルシステムを `/mnt` に接続してください」と指示します

```
Linux のディレクトリツリー

        /
       ├── home/
       │   └── user/
       ├── etc/
       ├── var/
       └── mnt/ ──────────── /dev/sdb のファイルシステムに接続！
            │
            └── (ここに /dev/sdb のファイルが見える)
```

`/mnt` が<strong>マウントポイント</strong>です

マウント後は `/mnt` にアクセスすると `/dev/sdb` の中身が見えます

`open("/mnt/data.txt")` のように、通常のファイル操作でブロックデバイス上のファイルを読み書きできます

マウントの詳細（Mount namespace やコンテナとの関係）は [06-namespace](../06-namespace.md) を参照してください

---

## なぜ3層に分離されているのか

### Windows も同じ仕組みを使っている

ブロックデバイス・ファイルシステム・マウントの 3 層構造は Linux 固有のものではありません

```
Windows の場合

  物理SSD ──── NTFSファイルシステム ──── C:\ にマウント
                                          ↑
                                    Windowsが起動時に
                                    自動でやっている

  USBメモリを挿す → NTFSまたはFAT32 → D:\ に自動マウント
                                          ↑
                                    「D:ドライブ」として
                                    見えるのは自動マウントの結果
```

Windows は「ブロックデバイス → ファイルシステム → マウント」の手順を自動でやっているだけです

Linux でもルートパーティションは起動時に自動でマウントされます

つまり、<strong>普段「普通のディレクトリ」に見えているもの自体が、すでにマウントの結果です</strong>

### 分離されていることのメリット

<strong>ブロックデバイスが独立</strong>

同じ物理ディスクをパーティションで分割して、異なるファイルシステムを載せることができます

1 つの SSD に ext4 の Linux 領域と FAT32 の Windows 共有領域を共存させられます

<strong>ファイルシステムが独立</strong>

用途に応じて最適なファイルシステムを選べます

ext4、XFS、Btrfs、FAT、NTFS など様々な種類があり、それぞれ得意分野が異なります

VFS（仮想ファイルシステム）がこの多様性を支えています（詳細は [filesystem](./filesystem.md) の「VFS：なぜ抽象化が必要なのか」を参照）

<strong>マウントが独立</strong>

同じファイルシステムを異なる場所にマウントしたり、読み取り専用でマウントしたりできます

Mount namespace は、この柔軟性を活かしてコンテナごとに異なるファイルシステムの見え方を実現しています（詳細は [06-namespace](../06-namespace.md) を参照）

### もし分離されていなかったら

```
× 1つのディスクに1つのファイルシステムしか置けない
× ファイルシステムの種類を変えるにはディスクごと交換
× USBメモリを挿しても、決まった場所にしか見えない
× コンテナに独自のファイルシステムを見せることができない
× 読み取り専用でマウントし直す、ということができない
```

3 層に分離されているからこそ、柔軟なストレージ管理が可能になっています

---

## ファイルシステムのシグネチャとwipefs

### シグネチャとは

ファイルシステムには<strong>シグネチャ</strong>（識別情報）があります

スーパーブロックの特定の位置に書き込まれた「これは ext4 です」という目印です

Linux はこのシグネチャを見て、ブロックデバイス上にどの種類のファイルシステムがあるかを判別します

### wipefs コマンド

<strong>wipefs</strong> は、ブロックデバイスからシグネチャを消すコマンドです

Linux のマニュアルには、こう書かれています

> wipefs can erase filesystem, raid or partition-table signatures (magic strings) from the specified device to make the signatures invisible for libblkid.

> wipefs は、指定したデバイスからファイルシステム、RAID、またはパーティションテーブルのシグネチャ（マジック文字列）を消去して、libblkid から見えなくすることができます

<strong>重要な点</strong>

> wipefs does not erase the filesystem itself nor any other data from the device.

> wipefs はファイルシステム自体やデバイス上の他のデータを消去しません

wipefs はシグネチャ（目印）だけを消します

ファイルシステムの構造やデータそのものは残っています

### マウント中に wipefs を実行するとどうなるか

マウント中のファイルシステムに対して `wipefs -a /dev/sdb` を実行するとどうなるでしょうか

<strong>実行直後</strong>

シグネチャはディスク上から消えますが、カーネルはすでにファイルシステムの構造をメモリ上にキャッシュしています

そのため、すぐには壊れません

マウントされたまま `/mnt` 以下のファイルにアクセスし続けることができます

<strong>アンマウント後に再マウントしようとすると</strong>

シグネチャが失われているため、カーネルはこのブロックデバイスにファイルシステムがあることを認識できません

`mount /dev/sdb /mnt` は失敗します

<strong>なぜ即座に壊れないのか</strong>

カーネルは、マウント時にファイルシステムの管理情報をメモリに読み込みます

マウント中はメモリ上のキャッシュを使ってファイル操作を処理するため、ディスク上のシグネチャが消えても動作に影響しません

しかし、アンマウントするとキャッシュは破棄されます

再度マウントするにはディスク上のシグネチャが必要ですが、それは wipefs で消されています

---

## 確認方法

### ブロックデバイスの一覧

```bash
lsblk
```

出力例

```
NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS
sda      8:0    0   100G  0 disk
├─sda1   8:1    0    50G  0 part /
└─sda2   8:2    0    50G  0 part /home
sdb      8:16   0    10G  0 disk
```

lsblk はディスク、パーティション、マウントポイントの関係をツリー形式で表示します

`/sys/block/` でもブロックデバイスの一覧を確認できます（詳細は [sys](./sys.md) を参照）

### ファイルシステムのシグネチャ

```bash
blkid /dev/sdb
```

出力例

```
/dev/sdb: UUID="xxxx-xxxx" BLOCK_SIZE="4096" TYPE="ext4"
```

`TYPE="ext4"` がファイルシステムのシグネチャから読み取られた情報です

### マウント状態

```bash
findmnt
```

出力例

```
TARGET        SOURCE     FSTYPE OPTIONS
/             /dev/sda1  ext4   rw,relatime
├─/home       /dev/sda2  ext4   rw,relatime
└─/mnt        /dev/sdb   ext4   rw,relatime
```

findmnt はマウントポイントとデバイスの対応をツリー形式で表示します

---

## 用語集

| 用語                 | 説明                                                                               |
| -------------------- | ---------------------------------------------------------------------------------- |
| ブロックデバイス     | データをブロック（かたまり）単位で読み書きするデバイス（HDD、SSD、USB メモリなど） |
| キャラクタデバイス   | データを 1 バイトずつ順番に読み書きするデバイス（キーボード、マウスなど）          |
| ブロック             | ディスク上のデータ管理の最小単位（通常 4KB）                                       |
| セクタ               | ディスクのハードウェアレベルの最小読み書き単位（通常 512B〜4KB）                   |
| パーティション       | 1 つのディスクを論理的に分割した区画                                               |
| ファイルシステム     | ブロックデバイス上のデータを「ファイル」として管理するための仕組み                 |
| スーパーブロック     | ファイルシステム全体の管理情報を保持するブロック                                   |
| シグネチャ           | ファイルシステムの種類を示す識別情報（マジック文字列）                             |
| mkfs                 | ブロックデバイスにファイルシステムの管理構造を書き込むコマンド                     |
| マウント             | ファイルシステムをディレクトリツリーに接続する操作                                 |
| マウントポイント     | ファイルシステムが接続されるディレクトリ                                           |
| ループバックデバイス | 通常のファイルを仮想的なブロックデバイスとして扱う仕組み                           |

---

## まとめ

<strong>ストレージの3層構造</strong>

| 層               | 説明                                    | 操作  |
| ---------------- | --------------------------------------- | ----- |
| ブロックデバイス | ディスクの物理的な表現（/dev/sda など） | なし  |
| ファイルシステム | 管理構造を書き込んだ状態                | mkfs  |
| マウント         | ディレクトリツリーへの接続              | mount |

<strong>覚えておくこと</strong>

| ポイント                           | 説明                                                 |
| ---------------------------------- | ---------------------------------------------------- |
| ブロックデバイスは「箱の並び」     | 管理構造がなければファイルは保存できない             |
| mkfs が管理構造を作る              | スーパーブロック、inode テーブル等を書き込む         |
| マウントで初めてアクセス可能になる | ディレクトリツリーに接続されて初めてファイル操作可能 |
| 3 層の分離が柔軟性を生む           | コンテナの仕組みもこの分離の上に成り立っている       |
| wipefs はシグネチャだけを消す      | データは残るが、再マウントできなくなる               |

---

## 参考資料

<strong>Linux マニュアル</strong>

- [lsblk(8) - Linux manual page](https://man7.org/linux/man-pages/man8/lsblk.8.html)
  - ブロックデバイスの一覧表示
- [mkfs(8) - Linux manual page](https://man7.org/linux/man-pages/man8/mkfs.8.html)
  - ファイルシステムの作成
- [mount(8) - Linux manual page](https://man7.org/linux/man-pages/man8/mount.8.html)
  - ファイルシステムのマウント
- [mount(2) - Linux manual page](https://man7.org/linux/man-pages/man2/mount.2.html)
  - マウントのシステムコール
- [loop(4) - Linux manual page](https://man7.org/linux/man-pages/man4/loop.4.html)
  - ループバックデバイス
- [wipefs(8) - Linux manual page](https://man7.org/linux/man-pages/man8/wipefs.8.html)
  - ファイルシステムシグネチャの消去

<strong>本編との関連</strong>

- [filesystem](./filesystem.md)
  - inode、ブロック、VFS の詳細
- [page](./page.md)
  - ページサイズとブロックサイズの関係
- [sys](./sys.md)
  - /sys/block/ でのブロックデバイス確認
- [06-namespace](../06-namespace.md)
  - Mount namespace とマウントの役割
- [mount-propagation](./mount-propagation.md)
  - マウント伝播の仕組み
