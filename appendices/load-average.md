<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# ロードアベレージは何を表しているのか

## はじめに

[01-kernel](../01-kernel.md) の「sysinfo() システムコール」で、<strong>ロードアベレージ</strong>という値が登場しました

```bash
uptime
```

出力例

```
 10:00:00 up 1 day,  0:00,  2 users,  load average: 0.50, 0.75, 1.00
```

この `0.50, 0.75, 1.00` という 3 つの数字は何を意味しているのでしょうか？

「CPU コア数と比較すればいい」とよく言われますが、それだけでは説明として不十分です

このドキュメントでは、ロードアベレージの正確な定義と、その解釈方法を説明します

---

## 目次

- [ロードアベレージとは](#ロードアベレージとは)
- [3つの値の意味](#3つの値の意味)
- [何がカウントされるのか](#何がカウントされるのか)
- [CPUコア数との関係](#cpuコア数との関係)
- [よくある誤解](#よくある誤解)
- [確認方法](#確認方法)
- [まとめ](#まとめ)
- [参考資料](#参考資料)

---

## ロードアベレージとは

### 基本的な定義

<strong>ロードアベレージ</strong>は、システムの「仕事待ち行列」の長さを表す指標です

Linux のマニュアルには、こう書かれています

> The load average is the number of jobs in the run queue (state R) or waiting for disk I/O (state D) averaged over 1, 5, and 15 minutes.

> ロードアベレージは、実行キュー内（R 状態）またはディスク I/O 待ち（D 状態）のジョブ数を、1 分、5 分、15 分で平均したものです

### 日常の例え

銀行の窓口に例えてみましょう

| 状況                               | ロードアベレージ       |
| ---------------------------------- | ---------------------- |
| 窓口が空いていて、待ち人数 0 人    | 0                      |
| 窓口が埋まっていて、待ち人数 1 人  | 約 2（対応中 + 待ち）  |
| 窓口が埋まっていて、待ち人数 10 人 | 約 11（対応中 + 待ち） |

ポイントは、<strong>窓口で対応中の人もカウントされる</strong>ことです

「待ち行列の長さ」と言われると「待っている人だけ」と思いがちですが、実際には「対応中（実行中）の人」も含まれます

---

## 3つの値の意味

### 1分、5分、15分

ロードアベレージは 3 つの値で表示されます

| 位置   | 期間    | 意味         |
| ------ | ------- | ------------ |
| 1 番目 | 1 分間  | 直近の負荷   |
| 2 番目 | 5 分間  | 短期的な傾向 |
| 3 番目 | 15 分間 | 長期的な傾向 |

### 傾向の読み取り

```
例1: 0.50, 0.75, 1.00
→ 負荷が下がっている（改善傾向）

例2: 1.00, 0.75, 0.50
→ 負荷が上がっている（悪化傾向）

例3: 0.80, 0.80, 0.80
→ 負荷が安定している
```

### 指数移動平均

実際の計算は「指数移動平均（Exponential Moving Average）」を使っています

これは「最近の値ほど影響が大きく、古い値は徐々に影響が小さくなる」計算方法です

<strong>なぜ単純平均ではないのか</strong>

単純平均（過去 N 回の値を足して N で割る）には問題があります

| 方式     | 問題点                                                       |
| -------- | ------------------------------------------------------------ |
| 単純平均 | 過去 N 回分の値をすべて記憶する必要がある（メモリを消費）    |
| 単純平均 | N 回前の古い値が突然消える（値がジャンプする）               |
| 指数移動 | 前回の計算結果と現在の値だけで計算できる（メモリ効率が良い） |
| 指数移動 | 古い値は徐々に影響が減る（滑らかに変化する）                 |

カーネルは 5 秒ごとにロードアベレージを更新しています

指数移動平均なら、前回の値と現在のプロセス数だけで新しい値を計算できます

<strong>計算式</strong>

```
新しい平均 = 古い平均 × 係数 + 現在の値 × (1 - 係数)
```

係数は時間窓によって異なります（1分、5分、15分でそれぞれ異なる係数を使用）

<strong>具体的なイメージ</strong>

| 時点      | 実際のプロセス数 | 1分平均への影響度（概算） |
| --------- | ---------------- | ------------------------- |
| 今        | 10               | 大きい（約 63%）          |
| 30秒前    | 5                | 中程度（約 23%）          |
| 1分前     | 2                | 小さい（約 9%）           |
| 2分前以降 | -                | ほとんど影響なし          |

この計算により、<strong>急激な変動が滑らかになり</strong>、瞬間的なスパイクに過剰反応しない値になります

例えば、一瞬だけ負荷が 100 になっても、ロードアベレージは緩やかに上昇し、すぐに元に戻ります

---

## 何がカウントされるのか

### カウント対象

ロードアベレージにカウントされるのは、以下のプロセスです

| 状態                       | 説明                  | カウントされるか |
| -------------------------- | --------------------- | ---------------- |
| R（Running）               | 実行中または CPU 待ち | ✅ はい          |
| D（Uninterruptible Sleep） | ディスク I/O 待ち     | ✅ はい          |
| S（Interruptible Sleep）   | イベント待ち          | ❌ いいえ        |
| T（Stopped）               | 停止中                | ❌ いいえ        |
| Z（Zombie）                | ゾンビ                | ❌ いいえ        |

### D状態が含まれる理由

D 状態（Uninterruptible Sleep）は、ディスク I/O などを待っている状態です

これは「CPU を使いたいが、データを待っている」状態です

例えば

- NFS サーバーからの応答待ち
- ディスクからのデータ読み込み待ち
- iSCSI ターゲットからの応答待ち

<strong>なぜ D 状態を含めるのか</strong>

D 状態のプロセスは CPU を使っていませんが、「仕事をしたいのに待たされている」状態です

これを含めることで、<strong>I/O ボトルネックを発見</strong>できます

例えば、CPU 使用率が 20% なのにロードアベレージが 10 の場合、残りの 8 は D 状態のプロセスです

これは「CPU は暇だが、ディスクやネットワークが詰まっている」ことを示唆します

D 状態のプロセスがロードアベレージに含まれるため、<strong>CPU 使用率が低いのにロードアベレージが高い</strong>という現象が起こります

### Linux 特有の動作

他の Unix 系 OS では、R 状態のプロセスだけをカウントするものもあります

Linux では D 状態も含めるため、ストレージの問題がロードアベレージに反映されます

<strong>歴史的背景：なぜ Linux は D 状態を含めたのか</strong>

初期の Unix システムでは、ロードアベレージは「CPU 待ちのプロセス数」だけを測定していました

しかし 1993 年、Linux の開発者 Matthias Urlichs がカーネルに変更を加え、D 状態のプロセスも含めるようにしました

当時の変更コミットにはこう書かれています

> I found that processes in `TASK_UNINTERRUPTIBLE` state should also be counted, otherwise I/O-bound systems would appear to have no load whatsoever.

> TASK_UNINTERRUPTIBLE 状態のプロセスもカウントすべきだと分かった<br>
> そうしないと、I/O 負荷の高いシステムが「負荷ゼロ」に見えてしまうからだ

<strong>もし D 状態を含めなかったら</strong>

| シナリオ                                     | D 状態なしの場合                                       |
| -------------------------------------------- | ------------------------------------------------------ |
| NFS サーバーがダウンし、多数のプロセスが待機 | ロードアベレージは低いまま（問題が見えない）           |
| HDD が故障寸前でリトライを繰り返している     | ロードアベレージは低いまま（CPU は使われていないため） |

D 状態を含めることで、<strong>I/O ボトルネックがロードアベレージに表れる</strong>ようになりました

<strong>他の OS との比較</strong>

| OS      | D 状態の扱い             |
| ------- | ------------------------ |
| Linux   | ロードアベレージに含める |
| FreeBSD | 含めない（CPU 待ちのみ） |
| Solaris | 含めない（CPU 待ちのみ） |
| macOS   | 含めない（BSD 由来）     |

このため、同じハードウェアでも Linux のロードアベレージは他の OS より高く見えることがあります

---

## CPUコア数との関係

### 基本的な目安

ロードアベレージは、CPU コア数と比較して解釈します

```bash
# CPU コア数を確認
nproc
# または
grep -c ^processor /proc/cpuinfo
```

### 目安の解釈

4 コア CPU の場合

| ロードアベレージ | 解釈                           |
| ---------------- | ------------------------------ |
| 0.5              | 余裕あり（約 12.5% の負荷）    |
| 2.0              | 余裕あり（約 50% の負荷）      |
| 4.0              | ちょうど飽和（約 100% の負荷） |
| 8.0              | 過負荷（待ち行列が発生）       |

### 単純な比率では不十分

「ロードアベレージ ÷ コア数」で負荷率を計算できますが、これは<strong>近似値</strong>です

D 状態（I/O 待ち）も含まれるため、CPU 負荷だけを反映しているわけではありません

---

## よくある誤解

### 誤解1：CPU使用率と同じ

<strong>ロードアベレージは CPU 使用率ではありません</strong>

| 指標             | 意味                                          |
| ---------------- | --------------------------------------------- |
| CPU 使用率       | CPU が実際に使われている割合                  |
| ロードアベレージ | CPU を使いたいプロセス + I/O 待ちプロセスの数 |

CPU 使用率が 50% でも、D 状態のプロセスが多ければロードアベレージは高くなります

### 誤解2：低ければ良い

ロードアベレージが 0 に近いことは、必ずしも良いことではありません

| ロードアベレージ | 解釈                                   |
| ---------------- | -------------------------------------- |
| 常に 0 に近い    | リソースが過剰（コスト的に非効率）     |
| コア数の 50〜70% | 適度な使用率                           |
| コア数以上       | 負荷が高い（必ずしも問題とは限らない） |

### 誤解3：高ければ必ず問題

ロードアベレージが高くても、プロセスが正常に動作していれば問題ありません

<strong>問題となるケース</strong>

- レスポンスタイムが悪化している
- ロードアベレージが長時間高止まりしている
- D 状態のプロセスが異常に多い

---

## 確認方法

### uptime コマンド

```bash
uptime
```

出力例

```
 10:00:00 up 1 day,  0:00,  2 users,  load average: 0.50, 0.75, 1.00
```

### /proc/loadavg

```bash
cat /proc/loadavg
```

出力例

```
0.50 0.75 1.00 2/150 12345
```

| フィールド | 意味                                  |
| ---------- | ------------------------------------- |
| 1〜3       | ロードアベレージ（1 分、5 分、15 分） |
| 4          | 実行中プロセス数 / 全プロセス数       |
| 5          | 最後に作成されたプロセスの PID        |

### top / htop

```bash
top
```

1 行目にロードアベレージが表示されます

### w コマンド

```bash
w
```

ログイン中のユーザーとロードアベレージを表示します

### 原因の調査

ロードアベレージが高い場合、原因を調査します

```bash
# R 状態のプロセスを確認（CPU 待ち）
ps aux | awk '$8 ~ /R/'

# D 状態のプロセスを確認（I/O 待ち）
ps aux | awk '$8 ~ /D/'
```

D 状態のプロセスが多い場合、ストレージに問題がある可能性があります

---

## まとめ

<strong>ロードアベレージとは</strong>

| ポイント           | 説明                              |
| ------------------ | --------------------------------- |
| 仕事待ち行列の長さ | R 状態 + D 状態のプロセス数の平均 |
| 3 つの値           | 1 分、5 分、15 分の移動平均       |
| CPU コア数と比較   | コア数以下なら余裕あり            |

<strong>覚えておくこと</strong>

| ポイント                     | 説明                                   |
| ---------------------------- | -------------------------------------- |
| CPU 使用率とは異なる         | D 状態（I/O 待ち）も含まれる           |
| D 状態が原因になることがある | CPU 使用率が低いのに高ロードアベレージ |
| 傾向を見る                   | 3 つの値の変化で改善/悪化を判断        |
| 絶対的な「良い値」はない     | システムの特性に依存                   |

---

## 参考資料

<strong>Linux マニュアル</strong>

- [proc(5) - Linux manual page](https://man7.org/linux/man-pages/man5/proc.5.html)
  - /proc/loadavg の詳細
- [sysinfo(2) - Linux manual page](https://man7.org/linux/man-pages/man2/sysinfo.2.html)
  - sysinfo() でのロードアベレージ取得
- [uptime(1) - Linux manual page](https://man7.org/linux/man-pages/man1/uptime.1.html)
  - uptime コマンド

<strong>本編との関連</strong>

- [01-kernel](../01-kernel.md)
  - sysinfo() システムコール
- [05-scheduler](../05-scheduler.md)
  - スケジューリングと R 状態
- [appendices/process-state.md](./process-state.md)
  - D 状態（Uninterruptible Sleep）の詳細
